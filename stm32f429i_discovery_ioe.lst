   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 2
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"stm32f429i_discovery_ioe.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.section	.text.IOE_GPIO_Config,"ax",%progbits
  21              		.align	2
  22              		.p2align 4,,15
  23              		.thumb
  24              		.thumb_func
  26              	IOE_GPIO_Config:
  27              	.LFB131:
  28              		.file 1 "stm32f429i_discovery_ioe.c"
   1:stm32f429i_discovery_ioe.c **** /**
   2:stm32f429i_discovery_ioe.c ****   ******************************************************************************
   3:stm32f429i_discovery_ioe.c ****   * @file    stm32f429i_discovery_ioe.c
   4:stm32f429i_discovery_ioe.c ****   * @author  MCD Application Team
   5:stm32f429i_discovery_ioe.c ****   * @version V1.0.1
   6:stm32f429i_discovery_ioe.c ****   * @date    28-October-2013
   7:stm32f429i_discovery_ioe.c ****   * @brief   This file provides a set of functions needed to manage the STMPE811
   8:stm32f429i_discovery_ioe.c ****   *          IO Expander device mounted on STM32F429I-DISCO Kit.
   9:stm32f429i_discovery_ioe.c ****   ******************************************************************************
  10:stm32f429i_discovery_ioe.c ****   * @attention
  11:stm32f429i_discovery_ioe.c ****   *
  12:stm32f429i_discovery_ioe.c ****   * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
  13:stm32f429i_discovery_ioe.c ****   *
  14:stm32f429i_discovery_ioe.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  15:stm32f429i_discovery_ioe.c ****   * You may not use this file except in compliance with the License.
  16:stm32f429i_discovery_ioe.c ****   * You may obtain a copy of the License at:
  17:stm32f429i_discovery_ioe.c ****   *
  18:stm32f429i_discovery_ioe.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  19:stm32f429i_discovery_ioe.c ****   *
  20:stm32f429i_discovery_ioe.c ****   * Unless required by applicable law or agreed to in writing, software 
  21:stm32f429i_discovery_ioe.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  22:stm32f429i_discovery_ioe.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  23:stm32f429i_discovery_ioe.c ****   * See the License for the specific language governing permissions and
  24:stm32f429i_discovery_ioe.c ****   * limitations under the License.
  25:stm32f429i_discovery_ioe.c ****   *
  26:stm32f429i_discovery_ioe.c ****   ******************************************************************************
  27:stm32f429i_discovery_ioe.c ****   */ 
  28:stm32f429i_discovery_ioe.c **** 
  29:stm32f429i_discovery_ioe.c ****   /* File Info : ---------------------------------------------------------------
  30:stm32f429i_discovery_ioe.c ****   
  31:stm32f429i_discovery_ioe.c ****     Note:
  32:stm32f429i_discovery_ioe.c ****     -----
  33:stm32f429i_discovery_ioe.c ****     - This driver uses the DMA method for sending and receiving data on I2C bus
  34:stm32f429i_discovery_ioe.c ****       which allow higher efficiency and reliability of the communication.  
  35:stm32f429i_discovery_ioe.c ****   
  36:stm32f429i_discovery_ioe.c ****     SUPPORTED FEATURES:
  37:stm32f429i_discovery_ioe.c ****       - Touch Panel Features: Single point mode (Polling/Interrupt)
  38:stm32f429i_discovery_ioe.c ****   ----------------------------------------------------------------------------*/
  39:stm32f429i_discovery_ioe.c **** 
  40:stm32f429i_discovery_ioe.c **** /* Includes ------------------------------------------------------------------*/
  41:stm32f429i_discovery_ioe.c **** #include "stm32f429i_discovery_ioe.h"
  42:stm32f429i_discovery_ioe.c **** 
  43:stm32f429i_discovery_ioe.c **** /** @addtogroup Utilities
  44:stm32f429i_discovery_ioe.c ****   * @{
  45:stm32f429i_discovery_ioe.c ****   */
  46:stm32f429i_discovery_ioe.c **** 
  47:stm32f429i_discovery_ioe.c **** /** @addtogroup STM32F4_DISCOVERY
  48:stm32f429i_discovery_ioe.c ****   * @{
  49:stm32f429i_discovery_ioe.c ****   */ 
  50:stm32f429i_discovery_ioe.c **** 
  51:stm32f429i_discovery_ioe.c **** /** @addtogroup STM32F429I_DISCOVERY
  52:stm32f429i_discovery_ioe.c ****   * @{
  53:stm32f429i_discovery_ioe.c ****   */
  54:stm32f429i_discovery_ioe.c ****     
  55:stm32f429i_discovery_ioe.c **** /** @defgroup STM32F429I_DISCOVERY_IOE 
  56:stm32f429i_discovery_ioe.c ****   * @brief  This file includes the IO Expander driver for STMPE811 IO Expander 
  57:stm32f429i_discovery_ioe.c ****   *         devices.
  58:stm32f429i_discovery_ioe.c ****   * @{
  59:stm32f429i_discovery_ioe.c ****   */ 
  60:stm32f429i_discovery_ioe.c ****   
  61:stm32f429i_discovery_ioe.c **** 
  62:stm32f429i_discovery_ioe.c **** /** @defgroup STM32F429I_DISCOVERY_IOE_Private_TypesDefinitions
  63:stm32f429i_discovery_ioe.c ****   * @{
  64:stm32f429i_discovery_ioe.c ****   */ 
  65:stm32f429i_discovery_ioe.c **** /**
  66:stm32f429i_discovery_ioe.c ****   * @}
  67:stm32f429i_discovery_ioe.c ****   */ 
  68:stm32f429i_discovery_ioe.c **** 
  69:stm32f429i_discovery_ioe.c **** 
  70:stm32f429i_discovery_ioe.c **** /** @defgroup STM32F429I_DISCOVERY_IOE_Private_Defines
  71:stm32f429i_discovery_ioe.c ****   * @{
  72:stm32f429i_discovery_ioe.c ****   */ 
  73:stm32f429i_discovery_ioe.c **** #define TIMEOUT_MAX    0x3000 /*<! The value of the maximal timeout for I2C waiting loops */
  74:stm32f429i_discovery_ioe.c **** /**
  75:stm32f429i_discovery_ioe.c ****   * @}
  76:stm32f429i_discovery_ioe.c ****   */ 
  77:stm32f429i_discovery_ioe.c **** 
  78:stm32f429i_discovery_ioe.c **** 
  79:stm32f429i_discovery_ioe.c **** /** @defgroup STM32F429I_DISCOVERY_IOE_Private_Macros
  80:stm32f429i_discovery_ioe.c ****   * @{
  81:stm32f429i_discovery_ioe.c ****   */ 
  82:stm32f429i_discovery_ioe.c **** /**
  83:stm32f429i_discovery_ioe.c ****   * @}
  84:stm32f429i_discovery_ioe.c ****   */ 
  85:stm32f429i_discovery_ioe.c **** 
  86:stm32f429i_discovery_ioe.c **** /** @defgroup STM32F429I_DISCOVERY_IOE_Private_Variables
  87:stm32f429i_discovery_ioe.c ****   * @{
  88:stm32f429i_discovery_ioe.c ****   */ 
  89:stm32f429i_discovery_ioe.c **** TP_STATE TP_State;              /* The global structure holding the TS state */
  90:stm32f429i_discovery_ioe.c **** 
  91:stm32f429i_discovery_ioe.c **** uint32_t IOE_TimeOut = TIMEOUT_MAX; /* Value of Timeout when I2C communication fails */
  92:stm32f429i_discovery_ioe.c **** /**
  93:stm32f429i_discovery_ioe.c ****   * @}
  94:stm32f429i_discovery_ioe.c ****   */ 
  95:stm32f429i_discovery_ioe.c **** 
  96:stm32f429i_discovery_ioe.c **** 
  97:stm32f429i_discovery_ioe.c **** /** @defgroup STM32F429I_DISCOVERY_IOE_Private_FunctionPrototypes
  98:stm32f429i_discovery_ioe.c ****   * @{
  99:stm32f429i_discovery_ioe.c ****   */ 
 100:stm32f429i_discovery_ioe.c **** static uint16_t IOE_TP_Read_X(void);
 101:stm32f429i_discovery_ioe.c **** static uint16_t IOE_TP_Read_Y(void);
 102:stm32f429i_discovery_ioe.c **** static uint16_t IOE_TP_Read_Z(void);
 103:stm32f429i_discovery_ioe.c **** static void     IOE_GPIO_Config(void);
 104:stm32f429i_discovery_ioe.c **** static void     IOE_I2C_Config(void);
 105:stm32f429i_discovery_ioe.c **** static void     IOE_DMA_Config(IOE_DMADirection_TypeDef Direction, uint8_t* buffer);
 106:stm32f429i_discovery_ioe.c **** 
 107:stm32f429i_discovery_ioe.c **** #ifndef USE_Delay
 108:stm32f429i_discovery_ioe.c **** static void delay(__IO uint32_t nCount);
 109:stm32f429i_discovery_ioe.c **** #endif /* USE_Delay */
 110:stm32f429i_discovery_ioe.c **** /**
 111:stm32f429i_discovery_ioe.c ****   * @}
 112:stm32f429i_discovery_ioe.c ****   */ 
 113:stm32f429i_discovery_ioe.c **** 
 114:stm32f429i_discovery_ioe.c **** 
 115:stm32f429i_discovery_ioe.c **** /** @defgroup STM32F429I_DISCOVERY_IOE_Private_Functions
 116:stm32f429i_discovery_ioe.c ****   * @{
 117:stm32f429i_discovery_ioe.c ****   */ 
 118:stm32f429i_discovery_ioe.c **** 
 119:stm32f429i_discovery_ioe.c **** 
 120:stm32f429i_discovery_ioe.c **** /**
 121:stm32f429i_discovery_ioe.c ****   * @brief  Initializes and Configures the IO_Expander Touch Panel Functionality 
 122:stm32f429i_discovery_ioe.c ****   *         and configures all STM32F429I_DISCO necessary
 123:stm32f429i_discovery_ioe.c ****   *         hardware (GPIOs, APB clocks ..).
 124:stm32f429i_discovery_ioe.c ****   * @param  None
 125:stm32f429i_discovery_ioe.c ****   * @retval IOE_OK if all initializations done correctly. Other value if error.
 126:stm32f429i_discovery_ioe.c ****   */
 127:stm32f429i_discovery_ioe.c **** uint8_t IOE_Config(void)
 128:stm32f429i_discovery_ioe.c **** {
 129:stm32f429i_discovery_ioe.c ****   /* Configure the needed pins */
 130:stm32f429i_discovery_ioe.c ****   IOE_GPIO_Config(); 
 131:stm32f429i_discovery_ioe.c ****   
 132:stm32f429i_discovery_ioe.c ****   /* I2C initialization */
 133:stm32f429i_discovery_ioe.c ****   IOE_I2C_Config();
 134:stm32f429i_discovery_ioe.c ****     
 135:stm32f429i_discovery_ioe.c ****   /* Read IO Expander ID  */
 136:stm32f429i_discovery_ioe.c ****   if(IOE_IsOperational())
 137:stm32f429i_discovery_ioe.c ****   {
 138:stm32f429i_discovery_ioe.c ****     return IOE_NOT_OPERATIONAL;
 139:stm32f429i_discovery_ioe.c ****   }
 140:stm32f429i_discovery_ioe.c ****   
 141:stm32f429i_discovery_ioe.c ****   /* Generate IO Expander Software reset */
 142:stm32f429i_discovery_ioe.c ****   IOE_Reset(); 
 143:stm32f429i_discovery_ioe.c ****   
 144:stm32f429i_discovery_ioe.c ****   /* IO Expander configuration */
 145:stm32f429i_discovery_ioe.c ****   /* Touch Panel controller and ADC configuration */
 146:stm32f429i_discovery_ioe.c ****   IOE_FnctCmd(IOE_ADC_FCT, ENABLE);
 147:stm32f429i_discovery_ioe.c ****   IOE_TP_Config();
 148:stm32f429i_discovery_ioe.c **** 
 149:stm32f429i_discovery_ioe.c ****   /* Configuration is OK */
 150:stm32f429i_discovery_ioe.c ****   return IOE_OK; 
 151:stm32f429i_discovery_ioe.c **** }
 152:stm32f429i_discovery_ioe.c **** 
 153:stm32f429i_discovery_ioe.c **** /**
 154:stm32f429i_discovery_ioe.c ****   * @brief  Enables the touch Panel interrupt.
 155:stm32f429i_discovery_ioe.c ****   * @param  None
 156:stm32f429i_discovery_ioe.c ****   * @retval IOE_OK: if all initializations are OK. Other value if error.
 157:stm32f429i_discovery_ioe.c ****   */
 158:stm32f429i_discovery_ioe.c **** uint8_t IOE_TPITConfig(void)
 159:stm32f429i_discovery_ioe.c **** {    
 160:stm32f429i_discovery_ioe.c ****   /* Enable the Global interrupt */  
 161:stm32f429i_discovery_ioe.c ****   IOE_GITCmd(ENABLE);     
 162:stm32f429i_discovery_ioe.c ****           
 163:stm32f429i_discovery_ioe.c ****   /* Enable the Global GPIO Interrupt */
 164:stm32f429i_discovery_ioe.c ****   IOE_GITConfig((uint8_t)(IOE_GIT_TOUCH | IOE_GIT_FTH | IOE_GIT_FOV), ENABLE);    
 165:stm32f429i_discovery_ioe.c ****     
 166:stm32f429i_discovery_ioe.c ****   /* Read the GPIO_IT_STA to clear all pending bits if any */
 167:stm32f429i_discovery_ioe.c ****   I2C_ReadDeviceRegister(IOE_REG_GPIO_INT_STA); 
 168:stm32f429i_discovery_ioe.c ****   
 169:stm32f429i_discovery_ioe.c ****   /* If all OK return IOE_OK */
 170:stm32f429i_discovery_ioe.c ****   return IOE_OK;
 171:stm32f429i_discovery_ioe.c **** }
 172:stm32f429i_discovery_ioe.c **** 
 173:stm32f429i_discovery_ioe.c **** /**
 174:stm32f429i_discovery_ioe.c ****   * @brief  Returns Status and positions of the Touch Panel.
 175:stm32f429i_discovery_ioe.c ****   * @param  None
 176:stm32f429i_discovery_ioe.c ****   * @retval Pointer to TP_STATE structure holding Touch Panel information.
 177:stm32f429i_discovery_ioe.c ****   */
 178:stm32f429i_discovery_ioe.c **** TP_STATE* IOE_TP_GetState(void)
 179:stm32f429i_discovery_ioe.c **** {
 180:stm32f429i_discovery_ioe.c ****   uint32_t xDiff, yDiff , x , y;
 181:stm32f429i_discovery_ioe.c ****   static uint32_t _x = 0, _y = 0;
 182:stm32f429i_discovery_ioe.c ****   
 183:stm32f429i_discovery_ioe.c ****   /* Check if the Touch detect event happened */
 184:stm32f429i_discovery_ioe.c ****   TP_State.TouchDetected = (I2C_ReadDeviceRegister(IOE_REG_TP_CTRL) & 0x80);
 185:stm32f429i_discovery_ioe.c ****   
 186:stm32f429i_discovery_ioe.c ****   if(TP_State.TouchDetected) 
 187:stm32f429i_discovery_ioe.c ****   {
 188:stm32f429i_discovery_ioe.c ****     x = IOE_TP_Read_X();
 189:stm32f429i_discovery_ioe.c ****     y = IOE_TP_Read_Y();
 190:stm32f429i_discovery_ioe.c ****     xDiff = x > _x? (x - _x): (_x - x);
 191:stm32f429i_discovery_ioe.c ****     yDiff = y > _y? (y - _y): (_y - y);       
 192:stm32f429i_discovery_ioe.c ****     if (xDiff + yDiff > 5)
 193:stm32f429i_discovery_ioe.c ****     {
 194:stm32f429i_discovery_ioe.c ****       _x = x;
 195:stm32f429i_discovery_ioe.c ****       _y = y;       
 196:stm32f429i_discovery_ioe.c ****     }
 197:stm32f429i_discovery_ioe.c ****   }  
 198:stm32f429i_discovery_ioe.c ****   /* Update the X position */
 199:stm32f429i_discovery_ioe.c ****   TP_State.X = _x;
 200:stm32f429i_discovery_ioe.c ****     
 201:stm32f429i_discovery_ioe.c ****   /* Update the Y position */  
 202:stm32f429i_discovery_ioe.c ****   TP_State.Y = _y;
 203:stm32f429i_discovery_ioe.c ****   /* Update the Z Pression index */  
 204:stm32f429i_discovery_ioe.c ****   TP_State.Z = IOE_TP_Read_Z();  
 205:stm32f429i_discovery_ioe.c ****   
 206:stm32f429i_discovery_ioe.c ****   /* Clear the interrupt pending bit and enable the FIFO again */
 207:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_FIFO_STA, 0x01);
 208:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_FIFO_STA, 0x00);
 209:stm32f429i_discovery_ioe.c ****   
 210:stm32f429i_discovery_ioe.c ****   /* Return pointer to the updated structure */
 211:stm32f429i_discovery_ioe.c ****   return &TP_State; 
 212:stm32f429i_discovery_ioe.c **** }
 213:stm32f429i_discovery_ioe.c **** 
 214:stm32f429i_discovery_ioe.c **** /**
 215:stm32f429i_discovery_ioe.c ****   * @brief  Checks the selected Global interrupt source pending bit
 216:stm32f429i_discovery_ioe.c ****   * @param  Global_IT: the Global interrupt source to be checked, could be:
 217:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_ADC : ADC interrupt    
 218:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_FE : Touch Panel Controller FIFO Error interrupt
 219:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_FF : Touch Panel Controller FIFO Full interrupt      
 220:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_FOV : Touch Panel Controller FIFO Overrun interrupt     
 221:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_FTH : Touch Panel Controller FIFO Threshold interrupt   
 222:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_TOUCH : Touch Panel Controller Touch Detected interrupt      
 223:stm32f429i_discovery_ioe.c ****   * @retval Status of the checked flag. Could be SET or RESET.
 224:stm32f429i_discovery_ioe.c ****   */
 225:stm32f429i_discovery_ioe.c **** FlagStatus IOE_GetGITStatus(uint8_t Global_IT)
 226:stm32f429i_discovery_ioe.c **** {
 227:stm32f429i_discovery_ioe.c ****   __IO uint8_t tmp = 0;
 228:stm32f429i_discovery_ioe.c ****  
 229:stm32f429i_discovery_ioe.c ****   /* Get the Interrupt status */
 230:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReadDeviceRegister(IOE_REG_INT_STA);
 231:stm32f429i_discovery_ioe.c ****   
 232:stm32f429i_discovery_ioe.c ****   if ((tmp & (uint8_t)Global_IT) != 0)
 233:stm32f429i_discovery_ioe.c ****   {
 234:stm32f429i_discovery_ioe.c ****     return SET;
 235:stm32f429i_discovery_ioe.c ****   }
 236:stm32f429i_discovery_ioe.c ****   else
 237:stm32f429i_discovery_ioe.c ****   {
 238:stm32f429i_discovery_ioe.c ****     return RESET;
 239:stm32f429i_discovery_ioe.c ****   }
 240:stm32f429i_discovery_ioe.c **** }
 241:stm32f429i_discovery_ioe.c **** 
 242:stm32f429i_discovery_ioe.c **** /**
 243:stm32f429i_discovery_ioe.c ****   * @brief  Clears the selected Global interrupt pending bit(s)
 244:stm32f429i_discovery_ioe.c ****   * @param  Global_IT: the Global interrupt to be cleared, could be any combination
 245:stm32f429i_discovery_ioe.c ****   *         of the following values:   
 246:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_ADC : ADC interrupt    
 247:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_FE : Touch Panel Controller FIFO Error interrupt
 248:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_FF : Touch Panel Controller FIFO Full interrupt      
 249:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_FOV : Touch Panel Controller FIFO Overrun interrupt     
 250:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_FTH : Touch Panel Controller FIFO Threshold interrupt   
 251:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_TOUCH : Touch Panel Controller Touch Detected interrupt 
 252:stm32f429i_discovery_ioe.c ****   * @retval IOE_OK: if all initializations are OK. Other value if error.
 253:stm32f429i_discovery_ioe.c ****   */
 254:stm32f429i_discovery_ioe.c **** uint8_t IOE_ClearGITPending(uint8_t Global_IT)
 255:stm32f429i_discovery_ioe.c **** {
 256:stm32f429i_discovery_ioe.c ****   /* Write 1 to the bits that have to be cleared */
 257:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_INT_STA, Global_IT); 
 258:stm32f429i_discovery_ioe.c **** 
 259:stm32f429i_discovery_ioe.c ****   /* If all OK return IOE_OK */
 260:stm32f429i_discovery_ioe.c ****   return IOE_OK;
 261:stm32f429i_discovery_ioe.c **** }
 262:stm32f429i_discovery_ioe.c **** 
 263:stm32f429i_discovery_ioe.c **** 
 264:stm32f429i_discovery_ioe.c **** /**
 265:stm32f429i_discovery_ioe.c ****   * @brief  Checks if the IOE device is correctly configured and 
 266:stm32f429i_discovery_ioe.c ****   *         communicates correctly ont the I2C bus.
 267:stm32f429i_discovery_ioe.c ****   * @param  None
 268:stm32f429i_discovery_ioe.c ****   * @retval IOE_OK if IOE is operational. Other value if failure.
 269:stm32f429i_discovery_ioe.c ****   */
 270:stm32f429i_discovery_ioe.c **** uint8_t IOE_IsOperational(void)
 271:stm32f429i_discovery_ioe.c **** {
 272:stm32f429i_discovery_ioe.c ****   /* Return Error if the ID is not correct */
 273:stm32f429i_discovery_ioe.c ****   if( IOE_ReadID() != (uint16_t)STMPE811_ID )
 274:stm32f429i_discovery_ioe.c ****   {
 275:stm32f429i_discovery_ioe.c ****     /* Check if a Timeout occurred */
 276:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut == 0)
 277:stm32f429i_discovery_ioe.c ****     {
 278:stm32f429i_discovery_ioe.c ****       return(IOE_TimeoutUserCallback());
 279:stm32f429i_discovery_ioe.c ****     }
 280:stm32f429i_discovery_ioe.c ****     else
 281:stm32f429i_discovery_ioe.c ****     {
 282:stm32f429i_discovery_ioe.c ****       return IOE_FAILURE; /* ID is not Correct */
 283:stm32f429i_discovery_ioe.c ****     }
 284:stm32f429i_discovery_ioe.c ****   } 
 285:stm32f429i_discovery_ioe.c ****   else 
 286:stm32f429i_discovery_ioe.c ****   {
 287:stm32f429i_discovery_ioe.c ****     return IOE_OK; /* ID is correct */
 288:stm32f429i_discovery_ioe.c ****   }
 289:stm32f429i_discovery_ioe.c **** }
 290:stm32f429i_discovery_ioe.c **** 
 291:stm32f429i_discovery_ioe.c **** /**
 292:stm32f429i_discovery_ioe.c ****   * @brief  Resets the IO Expander by Software (SYS_CTRL1, RESET bit).
 293:stm32f429i_discovery_ioe.c ****   * @param  None
 294:stm32f429i_discovery_ioe.c ****   * @retval IOE_OK: if all initializations are OK. Other value if error.
 295:stm32f429i_discovery_ioe.c ****   */
 296:stm32f429i_discovery_ioe.c **** uint8_t IOE_Reset(void)
 297:stm32f429i_discovery_ioe.c **** {
 298:stm32f429i_discovery_ioe.c ****   /* Power Down the IO_Expander */
 299:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_SYS_CTRL1, 0x02);
 300:stm32f429i_discovery_ioe.c **** 
 301:stm32f429i_discovery_ioe.c ****   /* wait for a delay to insure registers erasing */
 302:stm32f429i_discovery_ioe.c ****   _delay_(2); 
 303:stm32f429i_discovery_ioe.c ****   
 304:stm32f429i_discovery_ioe.c ****   /* Power On the Codec after the power off => all registers are reinitialized*/
 305:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_SYS_CTRL1, 0x00);
 306:stm32f429i_discovery_ioe.c ****   
 307:stm32f429i_discovery_ioe.c ****   /* If all OK return IOE_OK */
 308:stm32f429i_discovery_ioe.c ****   return IOE_OK;    
 309:stm32f429i_discovery_ioe.c **** }
 310:stm32f429i_discovery_ioe.c **** 
 311:stm32f429i_discovery_ioe.c **** /**
 312:stm32f429i_discovery_ioe.c ****   * @brief  Reads the IOE device ID.
 313:stm32f429i_discovery_ioe.c ****   * @param  None
 314:stm32f429i_discovery_ioe.c ****   * @retval The Device ID (two bytes).
 315:stm32f429i_discovery_ioe.c ****   */
 316:stm32f429i_discovery_ioe.c **** uint16_t IOE_ReadID(void)
 317:stm32f429i_discovery_ioe.c **** {
 318:stm32f429i_discovery_ioe.c ****   uint16_t tmp = 0;
 319:stm32f429i_discovery_ioe.c **** 
 320:stm32f429i_discovery_ioe.c ****   /* Read device ID  */
 321:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReadDeviceRegister(0);
 322:stm32f429i_discovery_ioe.c ****   tmp = (uint32_t)(tmp << 8);
 323:stm32f429i_discovery_ioe.c ****   tmp |= (uint32_t)I2C_ReadDeviceRegister(1);
 324:stm32f429i_discovery_ioe.c ****   
 325:stm32f429i_discovery_ioe.c ****   /* Return the ID */
 326:stm32f429i_discovery_ioe.c ****   return (uint16_t)tmp;
 327:stm32f429i_discovery_ioe.c **** }
 328:stm32f429i_discovery_ioe.c **** 
 329:stm32f429i_discovery_ioe.c **** /**
 330:stm32f429i_discovery_ioe.c ****   * @brief  Configures the selected IO Expander functionalities.
 331:stm32f429i_discovery_ioe.c ****   * @param  Fct: the functions to be configured. could be any 
 332:stm32f429i_discovery_ioe.c ****   *         combination of the following values:
 333:stm32f429i_discovery_ioe.c ****   *   @arg  IOE_IO_FCT : IO function
 334:stm32f429i_discovery_ioe.c ****   *   @arg  IOE_TP_FCT : Touch Panel function
 335:stm32f429i_discovery_ioe.c ****   *   @arg  IOE_ADC_FCT : ADC function
 336:stm32f429i_discovery_ioe.c ****   * @param  NewState: can be ENABLE pr DISABLE   
 337:stm32f429i_discovery_ioe.c ****   * @retval IOE_OK: if all initializations are OK. Other value if error.
 338:stm32f429i_discovery_ioe.c ****   */
 339:stm32f429i_discovery_ioe.c **** uint8_t IOE_FnctCmd(uint8_t Fct, FunctionalState NewState)
 340:stm32f429i_discovery_ioe.c **** {
 341:stm32f429i_discovery_ioe.c ****   uint8_t tmp = 0;
 342:stm32f429i_discovery_ioe.c ****   
 343:stm32f429i_discovery_ioe.c ****   /* Get the register value */
 344:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReadDeviceRegister(IOE_REG_SYS_CTRL2);
 345:stm32f429i_discovery_ioe.c ****   
 346:stm32f429i_discovery_ioe.c ****   if (NewState != DISABLE)
 347:stm32f429i_discovery_ioe.c ****   {
 348:stm32f429i_discovery_ioe.c ****     /* Set the Functionalities to be Enabled */    
 349:stm32f429i_discovery_ioe.c ****     tmp &= ~(uint8_t)Fct;
 350:stm32f429i_discovery_ioe.c ****   }
 351:stm32f429i_discovery_ioe.c ****   else
 352:stm32f429i_discovery_ioe.c ****   {
 353:stm32f429i_discovery_ioe.c ****     /* Set the Functionalities to be Disabled */    
 354:stm32f429i_discovery_ioe.c ****     tmp |= (uint8_t)Fct;  
 355:stm32f429i_discovery_ioe.c ****   }
 356:stm32f429i_discovery_ioe.c ****   
 357:stm32f429i_discovery_ioe.c ****   /* Set the register value */
 358:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_SYS_CTRL2, tmp);
 359:stm32f429i_discovery_ioe.c ****   
 360:stm32f429i_discovery_ioe.c ****   /* If all OK return IOE_OK */
 361:stm32f429i_discovery_ioe.c ****   return IOE_OK;    
 362:stm32f429i_discovery_ioe.c **** }
 363:stm32f429i_discovery_ioe.c **** 
 364:stm32f429i_discovery_ioe.c **** 
 365:stm32f429i_discovery_ioe.c **** /**
 366:stm32f429i_discovery_ioe.c ****   * @brief  Enables or disables the Global interrupt.
 367:stm32f429i_discovery_ioe.c ****   * @param  NewState: could be ENABLE or DISABLE.        
 368:stm32f429i_discovery_ioe.c ****   * @retval IOE_OK: if all initializations are OK. Other value if error.
 369:stm32f429i_discovery_ioe.c ****   */
 370:stm32f429i_discovery_ioe.c **** uint8_t IOE_GITCmd(FunctionalState NewState)
 371:stm32f429i_discovery_ioe.c **** {
 372:stm32f429i_discovery_ioe.c ****   uint8_t tmp = 0;
 373:stm32f429i_discovery_ioe.c ****   
 374:stm32f429i_discovery_ioe.c ****   /* Read the Interrupt Control register  */
 375:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReadDeviceRegister(IOE_REG_INT_CTRL);
 376:stm32f429i_discovery_ioe.c ****   
 377:stm32f429i_discovery_ioe.c ****   if (NewState != DISABLE)
 378:stm32f429i_discovery_ioe.c ****   {
 379:stm32f429i_discovery_ioe.c ****     /* Set the global interrupts to be Enabled */    
 380:stm32f429i_discovery_ioe.c ****     tmp |= (uint8_t)IOE_GIT_EN;
 381:stm32f429i_discovery_ioe.c ****   }
 382:stm32f429i_discovery_ioe.c ****   else
 383:stm32f429i_discovery_ioe.c ****   {
 384:stm32f429i_discovery_ioe.c ****     /* Set the global interrupts to be Disabled */    
 385:stm32f429i_discovery_ioe.c ****     tmp &= ~(uint8_t)IOE_GIT_EN;
 386:stm32f429i_discovery_ioe.c ****   }  
 387:stm32f429i_discovery_ioe.c ****   
 388:stm32f429i_discovery_ioe.c ****   /* Write Back the Interrupt Control register */
 389:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_INT_CTRL, tmp);
 390:stm32f429i_discovery_ioe.c **** 
 391:stm32f429i_discovery_ioe.c ****   /* If all OK return IOE_OK */
 392:stm32f429i_discovery_ioe.c ****   return IOE_OK;     
 393:stm32f429i_discovery_ioe.c **** }
 394:stm32f429i_discovery_ioe.c **** 
 395:stm32f429i_discovery_ioe.c **** /**
 396:stm32f429i_discovery_ioe.c ****   * @brief  Configures the selected source to generate or not a global interrupt
 397:stm32f429i_discovery_ioe.c ****   * @param Global_IT: the interrupt source to be configured, could be:
 398:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_ADC : ADC interrupt     
 399:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_FE : Touch Panel Controller FIFO Error interrupt
 400:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_FF : Touch Panel Controller FIFO Full interrupt      
 401:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_FOV : Touch Panel Controller FIFO Overrun interrupt     
 402:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_FTH : Touch Panel Controller FIFO Threshold interrupt   
 403:stm32f429i_discovery_ioe.c ****   *   @arg  Global_IT_TOUCH : Touch Panel Controller Touch Detected interrupt 
 404:stm32f429i_discovery_ioe.c ****   * @param  NewState: can be ENABLE pr DISABLE   
 405:stm32f429i_discovery_ioe.c ****   * @retval IOE_OK: if all initializations are OK. Other value if error.
 406:stm32f429i_discovery_ioe.c ****   */
 407:stm32f429i_discovery_ioe.c **** uint8_t IOE_GITConfig(uint8_t Global_IT, FunctionalState NewState)
 408:stm32f429i_discovery_ioe.c **** {
 409:stm32f429i_discovery_ioe.c ****   uint8_t tmp = 0;
 410:stm32f429i_discovery_ioe.c ****   
 411:stm32f429i_discovery_ioe.c ****   /* Get the current value of the INT_EN register */
 412:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReadDeviceRegister(IOE_REG_INT_EN);
 413:stm32f429i_discovery_ioe.c ****   
 414:stm32f429i_discovery_ioe.c ****   if (NewState != DISABLE)
 415:stm32f429i_discovery_ioe.c ****   {
 416:stm32f429i_discovery_ioe.c ****     /* Set the interrupts to be Enabled */    
 417:stm32f429i_discovery_ioe.c ****     tmp |= (uint8_t)Global_IT;  
 418:stm32f429i_discovery_ioe.c ****   }
 419:stm32f429i_discovery_ioe.c ****   else
 420:stm32f429i_discovery_ioe.c ****   {
 421:stm32f429i_discovery_ioe.c ****     /* Set the interrupts to be Disabled */    
 422:stm32f429i_discovery_ioe.c ****     tmp &= ~(uint8_t)Global_IT;
 423:stm32f429i_discovery_ioe.c ****   }
 424:stm32f429i_discovery_ioe.c ****   /* Set the register */
 425:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_INT_EN, tmp);
 426:stm32f429i_discovery_ioe.c ****   
 427:stm32f429i_discovery_ioe.c ****   /* If all OK return IOE_OK */
 428:stm32f429i_discovery_ioe.c ****   return IOE_OK;  
 429:stm32f429i_discovery_ioe.c **** }
 430:stm32f429i_discovery_ioe.c **** 
 431:stm32f429i_discovery_ioe.c **** /**
 432:stm32f429i_discovery_ioe.c ****   * @brief  Configures the touch Panel Controller (Single point detection)
 433:stm32f429i_discovery_ioe.c ****   * @param  None
 434:stm32f429i_discovery_ioe.c ****   * @retval IOE_OK if all initializations are OK. Other value if error.
 435:stm32f429i_discovery_ioe.c ****   */
 436:stm32f429i_discovery_ioe.c **** uint8_t IOE_TP_Config(void)
 437:stm32f429i_discovery_ioe.c **** { 
 438:stm32f429i_discovery_ioe.c ****   /* Enable touch Panel functionality */
 439:stm32f429i_discovery_ioe.c ****   IOE_FnctCmd(IOE_TP_FCT, ENABLE);
 440:stm32f429i_discovery_ioe.c ****   
 441:stm32f429i_discovery_ioe.c ****   /* Select Sample Time, bit number and ADC Reference */
 442:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_ADC_CTRL1, 0x49);
 443:stm32f429i_discovery_ioe.c ****   
 444:stm32f429i_discovery_ioe.c ****   /* Wait for ~20 ms */
 445:stm32f429i_discovery_ioe.c ****   _delay_(2);  
 446:stm32f429i_discovery_ioe.c ****   
 447:stm32f429i_discovery_ioe.c ****   /* Select the ADC clock speed: 3.25 MHz */
 448:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_ADC_CTRL2, 0x01);
 449:stm32f429i_discovery_ioe.c ****   
 450:stm32f429i_discovery_ioe.c ****   /* Select TSC pins in non default mode */  
 451:stm32f429i_discovery_ioe.c ****   IOE_IOAFConfig((uint8_t)TOUCH_IO_ALL, DISABLE);
 452:stm32f429i_discovery_ioe.c ****   
 453:stm32f429i_discovery_ioe.c ****   /* Select 2 nF filter capacitor */
 454:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_TP_CFG, 0x9A);   
 455:stm32f429i_discovery_ioe.c ****   
 456:stm32f429i_discovery_ioe.c ****   /* Select single point reading  */
 457:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_FIFO_TH, 0x01);
 458:stm32f429i_discovery_ioe.c ****   
 459:stm32f429i_discovery_ioe.c ****   /* Write 0x01 to clear the FIFO memory content. */
 460:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_FIFO_STA, 0x01);
 461:stm32f429i_discovery_ioe.c ****   
 462:stm32f429i_discovery_ioe.c ****   /* Write 0x00 to put the FIFO back into operation mode  */
 463:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_FIFO_STA, 0x00);
 464:stm32f429i_discovery_ioe.c ****   
 465:stm32f429i_discovery_ioe.c ****   /* set the data format for Z value: 7 fractional part and 1 whole part */
 466:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_TP_FRACT_XYZ, 0x01);
 467:stm32f429i_discovery_ioe.c ****   
 468:stm32f429i_discovery_ioe.c ****   /* set the driving capability of the device for TSC pins: 50mA */
 469:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_TP_I_DRIVE, 0x01);
 470:stm32f429i_discovery_ioe.c ****   
 471:stm32f429i_discovery_ioe.c ****   /* Use no tracking index, touch-panel controller operation mode (XYZ) and 
 472:stm32f429i_discovery_ioe.c ****      enable the TSC */
 473:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_TP_CTRL, 0x03);
 474:stm32f429i_discovery_ioe.c ****   
 475:stm32f429i_discovery_ioe.c ****   /*  Clear all the status pending bits */
 476:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_INT_STA, 0xFF); 
 477:stm32f429i_discovery_ioe.c ****   
 478:stm32f429i_discovery_ioe.c ****   /* Initialize the TS structure to their default values */ 
 479:stm32f429i_discovery_ioe.c ****   TP_State.TouchDetected = TP_State.X = TP_State.Y = TP_State.Z = 0;
 480:stm32f429i_discovery_ioe.c ****   
 481:stm32f429i_discovery_ioe.c ****   /* All configuration done */
 482:stm32f429i_discovery_ioe.c ****   return IOE_OK;  
 483:stm32f429i_discovery_ioe.c **** }
 484:stm32f429i_discovery_ioe.c **** 
 485:stm32f429i_discovery_ioe.c **** /**
 486:stm32f429i_discovery_ioe.c ****   * @brief  Configures the selected pin to be in Alternate function or not.
 487:stm32f429i_discovery_ioe.c ****   * @param  IO_Pin: IO_Pin_x, Where x can be from 0 to 7.   
 488:stm32f429i_discovery_ioe.c ****   * @param  NewState: State of the AF for the selected pin, could be 
 489:stm32f429i_discovery_ioe.c ****   *         ENABLE or DISABLE.       
 490:stm32f429i_discovery_ioe.c ****   * @retval IOE_OK: if all initializations are OK. Other value if error.
 491:stm32f429i_discovery_ioe.c ****   */
 492:stm32f429i_discovery_ioe.c **** uint8_t IOE_IOAFConfig(uint8_t IO_Pin, FunctionalState NewState)
 493:stm32f429i_discovery_ioe.c **** {
 494:stm32f429i_discovery_ioe.c ****   uint8_t tmp = 0;
 495:stm32f429i_discovery_ioe.c ****   
 496:stm32f429i_discovery_ioe.c ****   /* Get the current state of the GPIO_AF register */
 497:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReadDeviceRegister(IOE_REG_GPIO_AF);
 498:stm32f429i_discovery_ioe.c ****   
 499:stm32f429i_discovery_ioe.c ****   if (NewState != DISABLE)
 500:stm32f429i_discovery_ioe.c ****   {
 501:stm32f429i_discovery_ioe.c ****     /* Enable the selected pins alternate function */
 502:stm32f429i_discovery_ioe.c ****     tmp |= (uint8_t)IO_Pin;
 503:stm32f429i_discovery_ioe.c ****   }
 504:stm32f429i_discovery_ioe.c ****   else
 505:stm32f429i_discovery_ioe.c ****   {
 506:stm32f429i_discovery_ioe.c ****     /* Disable the selected pins alternate function */   
 507:stm32f429i_discovery_ioe.c ****     tmp &= ~(uint8_t)IO_Pin;   
 508:stm32f429i_discovery_ioe.c ****   }
 509:stm32f429i_discovery_ioe.c ****   
 510:stm32f429i_discovery_ioe.c ****   /* Write back the new value in GPIO_AF register */  
 511:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_GPIO_AF, tmp);  
 512:stm32f429i_discovery_ioe.c **** 
 513:stm32f429i_discovery_ioe.c ****   /* If all OK return IOE_OK */
 514:stm32f429i_discovery_ioe.c ****   return IOE_OK;
 515:stm32f429i_discovery_ioe.c **** }
 516:stm32f429i_discovery_ioe.c **** 
 517:stm32f429i_discovery_ioe.c **** /**
 518:stm32f429i_discovery_ioe.c ****   * @brief  Writes a value in a register of the device through I2C.
 519:stm32f429i_discovery_ioe.c ****   * @param  RegisterAddr: The target register address
 520:stm32f429i_discovery_ioe.c ****   * @param  RegisterValue: The target register value to be written 
 521:stm32f429i_discovery_ioe.c ****   * @retval IOE_OK: if all operations are OK. Other value if error.
 522:stm32f429i_discovery_ioe.c ****   */
 523:stm32f429i_discovery_ioe.c **** uint8_t I2C_DMA_WriteDeviceRegister(uint8_t RegisterAddr, uint8_t RegisterValue)
 524:stm32f429i_discovery_ioe.c **** {
 525:stm32f429i_discovery_ioe.c ****   uint32_t read_verif = 0;  
 526:stm32f429i_discovery_ioe.c ****   uint8_t IOE_BufferTX = 0;
 527:stm32f429i_discovery_ioe.c ****   
 528:stm32f429i_discovery_ioe.c ****   /* Get Value to be written */
 529:stm32f429i_discovery_ioe.c ****   IOE_BufferTX = RegisterValue;
 530:stm32f429i_discovery_ioe.c ****   
 531:stm32f429i_discovery_ioe.c ****   /* Configure DMA Peripheral */
 532:stm32f429i_discovery_ioe.c ****   IOE_DMA_Config(IOE_DMA_TX, (uint8_t*)(&IOE_BufferTX));
 533:stm32f429i_discovery_ioe.c ****   
 534:stm32f429i_discovery_ioe.c ****   /* Enable the I2C peripheral */
 535:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 536:stm32f429i_discovery_ioe.c ****   
 537:stm32f429i_discovery_ioe.c ****   /* Test on SB Flag */
 538:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 539:stm32f429i_discovery_ioe.c ****   while (I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB) == RESET) 
 540:stm32f429i_discovery_ioe.c ****   {
 541:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 542:stm32f429i_discovery_ioe.c ****   }
 543:stm32f429i_discovery_ioe.c ****   
 544:stm32f429i_discovery_ioe.c ****   /* Transmit the slave address and enable writing operation */
 545:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Transmitter);
 546:stm32f429i_discovery_ioe.c ****   
 547:stm32f429i_discovery_ioe.c ****   /* Test on ADDR Flag */
 548:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 549:stm32f429i_discovery_ioe.c ****   while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 550:stm32f429i_discovery_ioe.c ****   {
 551:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 552:stm32f429i_discovery_ioe.c ****   }
 553:stm32f429i_discovery_ioe.c ****   
 554:stm32f429i_discovery_ioe.c ****   /* Transmit the first address for r/w operations */
 555:stm32f429i_discovery_ioe.c ****   I2C_SendData(IOE_I2C, RegisterAddr);
 556:stm32f429i_discovery_ioe.c ****   
 557:stm32f429i_discovery_ioe.c ****   /* Test on TXE FLag (data dent) */
 558:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 559:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF))) 
 560:stm32f429i_discovery_ioe.c ****   {
 561:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 562:stm32f429i_discovery_ioe.c ****   }
 563:stm32f429i_discovery_ioe.c ****   
 564:stm32f429i_discovery_ioe.c ****   /* Enable I2C DMA request */
 565:stm32f429i_discovery_ioe.c ****   I2C_DMACmd(IOE_I2C,ENABLE);
 566:stm32f429i_discovery_ioe.c ****   
 567:stm32f429i_discovery_ioe.c ****   /* Enable DMA TX Channel */
 568:stm32f429i_discovery_ioe.c ****   DMA_Cmd(IOE_DMA_TX_STREAM, ENABLE);
 569:stm32f429i_discovery_ioe.c ****   
 570:stm32f429i_discovery_ioe.c ****   /* Wait until DMA Transfer Complete */
 571:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 572:stm32f429i_discovery_ioe.c ****   while (!DMA_GetFlagStatus(IOE_DMA_TX_STREAM,IOE_DMA_TX_TCFLAG))
 573:stm32f429i_discovery_ioe.c ****   {
 574:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 575:stm32f429i_discovery_ioe.c ****   }  
 576:stm32f429i_discovery_ioe.c ****   
 577:stm32f429i_discovery_ioe.c ****   /* Wait until BTF Flag is set before generating STOP */
 578:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = 0xFF * TIMEOUT_MAX;
 579:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF)))  
 580:stm32f429i_discovery_ioe.c ****   {
 581:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 582:stm32f429i_discovery_ioe.c ****   }
 583:stm32f429i_discovery_ioe.c ****   
 584:stm32f429i_discovery_ioe.c ****   /* Send STOP Condition */
 585:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTOP(IOE_I2C, ENABLE);
 586:stm32f429i_discovery_ioe.c ****   
 587:stm32f429i_discovery_ioe.c ****   /* Disable DMA TX Channel */
 588:stm32f429i_discovery_ioe.c ****   DMA_Cmd(IOE_DMA_TX_STREAM, DISABLE);
 589:stm32f429i_discovery_ioe.c ****   
 590:stm32f429i_discovery_ioe.c ****   /* Disable I2C DMA request */  
 591:stm32f429i_discovery_ioe.c ****   I2C_DMACmd(IOE_I2C,DISABLE);
 592:stm32f429i_discovery_ioe.c ****   
 593:stm32f429i_discovery_ioe.c ****   /* Clear DMA TX Transfer Complete Flag */
 594:stm32f429i_discovery_ioe.c ****   DMA_ClearFlag(IOE_DMA_TX_STREAM,IOE_DMA_TX_TCFLAG);
 595:stm32f429i_discovery_ioe.c ****   
 596:stm32f429i_discovery_ioe.c **** #ifdef VERIFY_WRITTENDATA
 597:stm32f429i_discovery_ioe.c ****   /* Verify (if needed) that the loaded data is correct  */
 598:stm32f429i_discovery_ioe.c ****   
 599:stm32f429i_discovery_ioe.c ****   /* Read the just written register*/
 600:stm32f429i_discovery_ioe.c ****   read_verif = I2C_ReadDeviceRegister(RegisterAddr);
 601:stm32f429i_discovery_ioe.c ****   /* Load the register and verify its value  */
 602:stm32f429i_discovery_ioe.c ****   if (read_verif != RegisterValue)
 603:stm32f429i_discovery_ioe.c ****   {
 604:stm32f429i_discovery_ioe.c ****     /* Control data wrongly transferred */
 605:stm32f429i_discovery_ioe.c ****     read_verif = IOE_FAILURE;
 606:stm32f429i_discovery_ioe.c ****   }
 607:stm32f429i_discovery_ioe.c ****   else
 608:stm32f429i_discovery_ioe.c ****   {
 609:stm32f429i_discovery_ioe.c ****     /* Control data correctly transferred */
 610:stm32f429i_discovery_ioe.c ****     read_verif = 0;
 611:stm32f429i_discovery_ioe.c ****   }
 612:stm32f429i_discovery_ioe.c **** #endif
 613:stm32f429i_discovery_ioe.c ****   
 614:stm32f429i_discovery_ioe.c ****   /* Return the verifying value: 0 (Passed) or 1 (Failed) */
 615:stm32f429i_discovery_ioe.c ****   return read_verif;
 616:stm32f429i_discovery_ioe.c **** }
 617:stm32f429i_discovery_ioe.c **** 
 618:stm32f429i_discovery_ioe.c **** /**
 619:stm32f429i_discovery_ioe.c ****   * @brief  Reads a register of the device through I2C.
 620:stm32f429i_discovery_ioe.c ****   * @param  RegisterAddr: The target register address (between 00x and 0x24)
 621:stm32f429i_discovery_ioe.c ****   * @retval The value of the read register (0xAA if Timeout occurred)   
 622:stm32f429i_discovery_ioe.c ****   */
 623:stm32f429i_discovery_ioe.c **** uint8_t I2C_DMA_ReadDeviceRegister(uint8_t RegisterAddr)
 624:stm32f429i_discovery_ioe.c **** {
 625:stm32f429i_discovery_ioe.c ****   uint8_t IOE_BufferRX[2] = {0x00, 0x00};  
 626:stm32f429i_discovery_ioe.c ****   
 627:stm32f429i_discovery_ioe.c ****   /* Configure DMA Peripheral */
 628:stm32f429i_discovery_ioe.c ****   IOE_DMA_Config(IOE_DMA_RX, (uint8_t*)IOE_BufferRX);
 629:stm32f429i_discovery_ioe.c ****   
 630:stm32f429i_discovery_ioe.c ****   /* Enable DMA NACK automatic generation */
 631:stm32f429i_discovery_ioe.c ****   I2C_DMALastTransferCmd(IOE_I2C, ENABLE);
 632:stm32f429i_discovery_ioe.c ****   
 633:stm32f429i_discovery_ioe.c ****   /* Enable the I2C peripheral */
 634:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 635:stm32f429i_discovery_ioe.c ****   
 636:stm32f429i_discovery_ioe.c ****   /* Test on SB Flag */
 637:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 638:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
 639:stm32f429i_discovery_ioe.c ****   {
 640:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 641:stm32f429i_discovery_ioe.c ****   }
 642:stm32f429i_discovery_ioe.c ****   
 643:stm32f429i_discovery_ioe.c ****   /* Send device address for write */
 644:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Transmitter);
 645:stm32f429i_discovery_ioe.c ****   
 646:stm32f429i_discovery_ioe.c ****   /* Test on ADDR Flag */
 647:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 648:stm32f429i_discovery_ioe.c ****   while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) 
 649:stm32f429i_discovery_ioe.c ****   {
 650:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 651:stm32f429i_discovery_ioe.c ****   }
 652:stm32f429i_discovery_ioe.c ****   
 653:stm32f429i_discovery_ioe.c ****   /* Send the device's internal address to write to */
 654:stm32f429i_discovery_ioe.c ****   I2C_SendData(IOE_I2C, RegisterAddr);  
 655:stm32f429i_discovery_ioe.c ****   
 656:stm32f429i_discovery_ioe.c ****   /* Test on TXE FLag (data dent) */
 657:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 658:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF))) 
 659:stm32f429i_discovery_ioe.c ****   {
 660:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 661:stm32f429i_discovery_ioe.c ****   }
 662:stm32f429i_discovery_ioe.c ****   
 663:stm32f429i_discovery_ioe.c ****   /* Send START condition a second time */  
 664:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 665:stm32f429i_discovery_ioe.c ****   
 666:stm32f429i_discovery_ioe.c ****   /* Test on SB Flag */
 667:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 668:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
 669:stm32f429i_discovery_ioe.c ****   {
 670:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 671:stm32f429i_discovery_ioe.c ****   }
 672:stm32f429i_discovery_ioe.c ****   
 673:stm32f429i_discovery_ioe.c ****   /* Send IOExpander address for read */
 674:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Receiver);
 675:stm32f429i_discovery_ioe.c ****   
 676:stm32f429i_discovery_ioe.c ****   /* Test on ADDR Flag */
 677:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 678:stm32f429i_discovery_ioe.c ****   while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))   
 679:stm32f429i_discovery_ioe.c ****   {
 680:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 681:stm32f429i_discovery_ioe.c ****   }
 682:stm32f429i_discovery_ioe.c ****     
 683:stm32f429i_discovery_ioe.c ****   /* Enable I2C DMA request */
 684:stm32f429i_discovery_ioe.c ****   I2C_DMACmd(IOE_I2C,ENABLE);
 685:stm32f429i_discovery_ioe.c ****   
 686:stm32f429i_discovery_ioe.c ****   /* Enable DMA RX Channel */
 687:stm32f429i_discovery_ioe.c ****   DMA_Cmd(IOE_DMA_RX_STREAM, ENABLE);
 688:stm32f429i_discovery_ioe.c ****   
 689:stm32f429i_discovery_ioe.c ****   /* Wait until DMA Transfer Complete */
 690:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = 2 * TIMEOUT_MAX;
 691:stm32f429i_discovery_ioe.c ****   while (!DMA_GetFlagStatus(IOE_DMA_RX_STREAM,IOE_DMA_RX_TCFLAG))
 692:stm32f429i_discovery_ioe.c ****   {
 693:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 694:stm32f429i_discovery_ioe.c ****   }        
 695:stm32f429i_discovery_ioe.c ****   
 696:stm32f429i_discovery_ioe.c ****   /* Send STOP Condition */
 697:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTOP(IOE_I2C, ENABLE);
 698:stm32f429i_discovery_ioe.c ****   
 699:stm32f429i_discovery_ioe.c ****   /* Disable DMA RX Channel */
 700:stm32f429i_discovery_ioe.c ****   DMA_Cmd(IOE_DMA_RX_STREAM, DISABLE);
 701:stm32f429i_discovery_ioe.c ****   
 702:stm32f429i_discovery_ioe.c ****   /* Disable I2C DMA request */  
 703:stm32f429i_discovery_ioe.c ****   I2C_DMACmd(IOE_I2C,DISABLE);
 704:stm32f429i_discovery_ioe.c ****   
 705:stm32f429i_discovery_ioe.c ****   /* Clear DMA RX Transfer Complete Flag */
 706:stm32f429i_discovery_ioe.c ****  DMA_ClearFlag(IOE_DMA_RX_STREAM,IOE_DMA_RX_TCFLAG);
 707:stm32f429i_discovery_ioe.c ****   
 708:stm32f429i_discovery_ioe.c ****   /* return a pointer to the IOE_Buffer */
 709:stm32f429i_discovery_ioe.c ****   return (uint8_t)IOE_BufferRX[0];
 710:stm32f429i_discovery_ioe.c **** }
 711:stm32f429i_discovery_ioe.c **** 
 712:stm32f429i_discovery_ioe.c **** 
 713:stm32f429i_discovery_ioe.c **** /**
 714:stm32f429i_discovery_ioe.c ****   * @brief  Reads a buffer of 2 bytes from the device registers.
 715:stm32f429i_discovery_ioe.c ****   * @param  RegisterAddr: The target register address (between 00x and 0x24)
 716:stm32f429i_discovery_ioe.c ****   * @retval A pointer to the buffer containing the two returned bytes (in halfword).  
 717:stm32f429i_discovery_ioe.c ****   */
 718:stm32f429i_discovery_ioe.c **** uint16_t I2C_DMA_ReadDataBuffer(uint32_t RegisterAddr)
 719:stm32f429i_discovery_ioe.c **** { 
 720:stm32f429i_discovery_ioe.c ****   uint8_t tmp= 0;
 721:stm32f429i_discovery_ioe.c ****   uint8_t IOE_BufferRX[2] = {0x00, 0x00};  
 722:stm32f429i_discovery_ioe.c ****   
 723:stm32f429i_discovery_ioe.c ****   /* Configure DMA Peripheral */
 724:stm32f429i_discovery_ioe.c ****   IOE_DMA_Config(IOE_DMA_RX, (uint8_t*)IOE_BufferRX);
 725:stm32f429i_discovery_ioe.c ****   
 726:stm32f429i_discovery_ioe.c ****   /* Enable DMA NACK automatic generation */
 727:stm32f429i_discovery_ioe.c ****   I2C_DMALastTransferCmd(IOE_I2C, ENABLE);
 728:stm32f429i_discovery_ioe.c ****   
 729:stm32f429i_discovery_ioe.c ****   /* Enable the I2C peripheral */
 730:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 731:stm32f429i_discovery_ioe.c ****   
 732:stm32f429i_discovery_ioe.c ****   /* Test on SB Flag */
 733:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 734:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
 735:stm32f429i_discovery_ioe.c ****   {
 736:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 737:stm32f429i_discovery_ioe.c ****   }
 738:stm32f429i_discovery_ioe.c ****   
 739:stm32f429i_discovery_ioe.c ****   /* Send device address for write */
 740:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Transmitter);
 741:stm32f429i_discovery_ioe.c ****   
 742:stm32f429i_discovery_ioe.c ****   /* Test on ADDR Flag */
 743:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 744:stm32f429i_discovery_ioe.c ****   while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 745:stm32f429i_discovery_ioe.c ****   {
 746:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 747:stm32f429i_discovery_ioe.c ****   }
 748:stm32f429i_discovery_ioe.c ****   
 749:stm32f429i_discovery_ioe.c ****   /* Send the device's internal address to write to */
 750:stm32f429i_discovery_ioe.c ****   I2C_SendData(IOE_I2C, RegisterAddr);  
 751:stm32f429i_discovery_ioe.c ****   
 752:stm32f429i_discovery_ioe.c ****   /* Test on TXE FLag (data dent) */
 753:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 754:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF))) 
 755:stm32f429i_discovery_ioe.c ****   {
 756:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 757:stm32f429i_discovery_ioe.c ****   }
 758:stm32f429i_discovery_ioe.c ****   
 759:stm32f429i_discovery_ioe.c ****   /* Send START condition a second time */  
 760:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 761:stm32f429i_discovery_ioe.c ****   
 762:stm32f429i_discovery_ioe.c ****   /* Test on SB Flag */
 763:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 764:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
 765:stm32f429i_discovery_ioe.c ****   {
 766:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 767:stm32f429i_discovery_ioe.c ****   }
 768:stm32f429i_discovery_ioe.c ****   
 769:stm32f429i_discovery_ioe.c ****   /* Send IO Expander address for read */
 770:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Receiver);
 771:stm32f429i_discovery_ioe.c ****   
 772:stm32f429i_discovery_ioe.c ****   /* Test on ADDR Flag */
 773:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 774:stm32f429i_discovery_ioe.c ****   while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))   
 775:stm32f429i_discovery_ioe.c ****   {
 776:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 777:stm32f429i_discovery_ioe.c ****   }
 778:stm32f429i_discovery_ioe.c ****   
 779:stm32f429i_discovery_ioe.c ****   /* Enable I2C DMA request */
 780:stm32f429i_discovery_ioe.c ****   I2C_DMACmd(IOE_I2C,ENABLE);
 781:stm32f429i_discovery_ioe.c ****   
 782:stm32f429i_discovery_ioe.c ****   /* Enable DMA RX Channel */
 783:stm32f429i_discovery_ioe.c ****   DMA_Cmd(IOE_DMA_RX_STREAM, ENABLE);
 784:stm32f429i_discovery_ioe.c ****   
 785:stm32f429i_discovery_ioe.c ****   /* Wait until DMA Transfer Complete */
 786:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = 2 * TIMEOUT_MAX;
 787:stm32f429i_discovery_ioe.c ****   while (!DMA_GetFlagStatus(IOE_DMA_RX_STREAM, IOE_DMA_RX_TCFLAG))
 788:stm32f429i_discovery_ioe.c ****   {
 789:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 790:stm32f429i_discovery_ioe.c ****   }        
 791:stm32f429i_discovery_ioe.c ****   
 792:stm32f429i_discovery_ioe.c ****   /* Send STOP Condition */
 793:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTOP(IOE_I2C, ENABLE);
 794:stm32f429i_discovery_ioe.c ****   
 795:stm32f429i_discovery_ioe.c ****   /* Disable DMA RX Channel */
 796:stm32f429i_discovery_ioe.c ****   DMA_Cmd(IOE_DMA_RX_STREAM, DISABLE);
 797:stm32f429i_discovery_ioe.c ****   
 798:stm32f429i_discovery_ioe.c ****   /* Disable I2C DMA request */  
 799:stm32f429i_discovery_ioe.c ****   I2C_DMACmd(IOE_I2C,DISABLE);
 800:stm32f429i_discovery_ioe.c ****   
 801:stm32f429i_discovery_ioe.c ****   /* Clear DMA RX Transfer Complete Flag */
 802:stm32f429i_discovery_ioe.c ****   DMA_ClearFlag(IOE_DMA_RX_STREAM,IOE_DMA_RX_TCFLAG);
 803:stm32f429i_discovery_ioe.c ****   
 804:stm32f429i_discovery_ioe.c ****   /* Reorganize received data */  
 805:stm32f429i_discovery_ioe.c ****   tmp = IOE_BufferRX[0];
 806:stm32f429i_discovery_ioe.c ****   IOE_BufferRX[0] = IOE_BufferRX[1];
 807:stm32f429i_discovery_ioe.c ****   IOE_BufferRX[1] = tmp;
 808:stm32f429i_discovery_ioe.c ****   
 809:stm32f429i_discovery_ioe.c ****   /* return the data */
 810:stm32f429i_discovery_ioe.c ****   return (uint16_t) ((uint16_t)IOE_BufferRX[0] | (uint16_t)IOE_BufferRX[1]<< 8);
 811:stm32f429i_discovery_ioe.c **** }
 812:stm32f429i_discovery_ioe.c **** 
 813:stm32f429i_discovery_ioe.c **** 
 814:stm32f429i_discovery_ioe.c **** /**
 815:stm32f429i_discovery_ioe.c ****   * @brief  Return Touch Panel X position value
 816:stm32f429i_discovery_ioe.c ****   * @param  None
 817:stm32f429i_discovery_ioe.c ****   * @retval X position.
 818:stm32f429i_discovery_ioe.c ****   */
 819:stm32f429i_discovery_ioe.c **** static uint16_t IOE_TP_Read_X(void)
 820:stm32f429i_discovery_ioe.c **** {
 821:stm32f429i_discovery_ioe.c ****   int32_t x, xr;
 822:stm32f429i_discovery_ioe.c ****   
 823:stm32f429i_discovery_ioe.c ****   /* Read x value from DATA_X register */
 824:stm32f429i_discovery_ioe.c ****   x = I2C_ReadDataBuffer(IOE_REG_TP_DATA_X);
 825:stm32f429i_discovery_ioe.c ****   
 826:stm32f429i_discovery_ioe.c ****   /* x value first correction */
 827:stm32f429i_discovery_ioe.c ****   if(x <= 3000)
 828:stm32f429i_discovery_ioe.c ****   {
 829:stm32f429i_discovery_ioe.c ****   x = 3870 - x;
 830:stm32f429i_discovery_ioe.c ****   }
 831:stm32f429i_discovery_ioe.c ****   else
 832:stm32f429i_discovery_ioe.c ****   {
 833:stm32f429i_discovery_ioe.c ****    x = 3800 - x;
 834:stm32f429i_discovery_ioe.c ****   }
 835:stm32f429i_discovery_ioe.c ****   
 836:stm32f429i_discovery_ioe.c ****   /* x value second correction */  
 837:stm32f429i_discovery_ioe.c ****   xr = x / 15;
 838:stm32f429i_discovery_ioe.c ****   
 839:stm32f429i_discovery_ioe.c ****   /* return x position value */
 840:stm32f429i_discovery_ioe.c ****   if(xr <= 0)
 841:stm32f429i_discovery_ioe.c ****   {
 842:stm32f429i_discovery_ioe.c ****     xr = 0;
 843:stm32f429i_discovery_ioe.c ****   }
 844:stm32f429i_discovery_ioe.c ****   else if (xr > 240)
 845:stm32f429i_discovery_ioe.c ****   {
 846:stm32f429i_discovery_ioe.c ****     xr = 239;
 847:stm32f429i_discovery_ioe.c ****   }
 848:stm32f429i_discovery_ioe.c ****   else 
 849:stm32f429i_discovery_ioe.c ****   {}
 850:stm32f429i_discovery_ioe.c ****   return (uint16_t)(xr); 
 851:stm32f429i_discovery_ioe.c **** }
 852:stm32f429i_discovery_ioe.c **** 
 853:stm32f429i_discovery_ioe.c **** /**
 854:stm32f429i_discovery_ioe.c ****   * @brief  Return Touch Panel Y position value
 855:stm32f429i_discovery_ioe.c ****   * @param  None
 856:stm32f429i_discovery_ioe.c ****   * @retval Y position.
 857:stm32f429i_discovery_ioe.c ****   */
 858:stm32f429i_discovery_ioe.c **** static uint16_t IOE_TP_Read_Y(void)
 859:stm32f429i_discovery_ioe.c **** {
 860:stm32f429i_discovery_ioe.c ****   int32_t y, yr;
 861:stm32f429i_discovery_ioe.c ****   
 862:stm32f429i_discovery_ioe.c ****   /* Read y value from DATA_Y register */
 863:stm32f429i_discovery_ioe.c ****   y = I2C_ReadDataBuffer(IOE_REG_TP_DATA_Y);
 864:stm32f429i_discovery_ioe.c ****   
 865:stm32f429i_discovery_ioe.c ****   /* y value first correction */
 866:stm32f429i_discovery_ioe.c **** 
 867:stm32f429i_discovery_ioe.c ****   y -= 360;  
 868:stm32f429i_discovery_ioe.c ****   
 869:stm32f429i_discovery_ioe.c ****   /* y value second correction */
 870:stm32f429i_discovery_ioe.c ****   yr = y / 11;
 871:stm32f429i_discovery_ioe.c ****   
 872:stm32f429i_discovery_ioe.c ****   /* return y position value */
 873:stm32f429i_discovery_ioe.c ****   if(yr <= 0)
 874:stm32f429i_discovery_ioe.c ****   {
 875:stm32f429i_discovery_ioe.c ****     yr = 0;
 876:stm32f429i_discovery_ioe.c ****   }
 877:stm32f429i_discovery_ioe.c ****   else if (yr > 320)
 878:stm32f429i_discovery_ioe.c ****   {
 879:stm32f429i_discovery_ioe.c ****     yr = 319;
 880:stm32f429i_discovery_ioe.c ****   }
 881:stm32f429i_discovery_ioe.c ****   else
 882:stm32f429i_discovery_ioe.c ****   {}
 883:stm32f429i_discovery_ioe.c ****   return (uint16_t)(yr); 
 884:stm32f429i_discovery_ioe.c **** }
 885:stm32f429i_discovery_ioe.c **** 
 886:stm32f429i_discovery_ioe.c **** /**
 887:stm32f429i_discovery_ioe.c ****   * @brief  Return Touch Panel Z position value
 888:stm32f429i_discovery_ioe.c ****   * @param  None
 889:stm32f429i_discovery_ioe.c ****   * @retval Z position.
 890:stm32f429i_discovery_ioe.c ****   */
 891:stm32f429i_discovery_ioe.c **** static uint16_t IOE_TP_Read_Z(void)
 892:stm32f429i_discovery_ioe.c **** {
 893:stm32f429i_discovery_ioe.c ****   uint32_t z;
 894:stm32f429i_discovery_ioe.c ****   
 895:stm32f429i_discovery_ioe.c ****   /* Read z value from DATA_Z register */
 896:stm32f429i_discovery_ioe.c ****   z = I2C_ReadDataBuffer(IOE_REG_TP_DATA_Z);
 897:stm32f429i_discovery_ioe.c **** 
 898:stm32f429i_discovery_ioe.c ****   /* return z position value */
 899:stm32f429i_discovery_ioe.c ****   if(z <= 0)
 900:stm32f429i_discovery_ioe.c ****     z = 0;
 901:stm32f429i_discovery_ioe.c ****   return (uint16_t)(z); 
 902:stm32f429i_discovery_ioe.c **** }
 903:stm32f429i_discovery_ioe.c **** 
 904:stm32f429i_discovery_ioe.c **** /**
 905:stm32f429i_discovery_ioe.c ****   * @brief  Initializes the GPIO pins used by the IO expander.
 906:stm32f429i_discovery_ioe.c ****   * @param  None
 907:stm32f429i_discovery_ioe.c ****   * @retval None
 908:stm32f429i_discovery_ioe.c ****   */
 909:stm32f429i_discovery_ioe.c **** static void IOE_GPIO_Config(void)
 910:stm32f429i_discovery_ioe.c **** {
  29              		.loc 1 910 0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 8
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33 0000 30B5     		push	{r4, r5, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 12
  36              		.cfi_offset 4, -12
  37              		.cfi_offset 5, -8
  38              		.cfi_offset 14, -4
 911:stm32f429i_discovery_ioe.c ****   GPIO_InitTypeDef GPIO_InitStructure;
 912:stm32f429i_discovery_ioe.c ****   
 913:stm32f429i_discovery_ioe.c ****   /* Enable IOE_I2C and IOE_I2C_GPIO_PORT & Alternate Function clocks */
 914:stm32f429i_discovery_ioe.c ****   RCC_APB1PeriphClockCmd(IOE_I2C_CLK, ENABLE);
  39              		.loc 1 914 0
  40 0002 0121     		movs	r1, #1
 910:stm32f429i_discovery_ioe.c **** {
  41              		.loc 1 910 0
  42 0004 83B0     		sub	sp, sp, #12
  43              	.LCFI1:
  44              		.cfi_def_cfa_offset 24
  45              		.loc 1 914 0
  46 0006 4FF40000 		mov	r0, #8388608
  47 000a FFF7FEFF 		bl	RCC_APB1PeriphClockCmd
  48              	.LVL0:
 915:stm32f429i_discovery_ioe.c ****   RCC_AHB1PeriphClockCmd(IOE_I2C_SCL_GPIO_CLK | IOE_I2C_SDA_GPIO_CLK |
  49              		.loc 1 915 0
  50 000e 0121     		movs	r1, #1
  51 0010 40F20510 		movw	r0, #261
  52 0014 FFF7FEFF 		bl	RCC_AHB1PeriphClockCmd
  53              	.LVL1:
 916:stm32f429i_discovery_ioe.c ****                          IOE_IT_GPIO_CLK, ENABLE);
 917:stm32f429i_discovery_ioe.c ****   RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
  54              		.loc 1 917 0
  55 0018 0121     		movs	r1, #1
  56 001a 4FF48040 		mov	r0, #16384
  57 001e FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
  58              	.LVL2:
 918:stm32f429i_discovery_ioe.c ****   
 919:stm32f429i_discovery_ioe.c ****   /* Reset IOE_I2C IP */
 920:stm32f429i_discovery_ioe.c ****   RCC_APB1PeriphResetCmd(IOE_I2C_CLK, ENABLE);
 921:stm32f429i_discovery_ioe.c ****   /* Release reset signal of IOE_I2C IP */
 922:stm32f429i_discovery_ioe.c ****   RCC_APB1PeriphResetCmd(IOE_I2C_CLK, DISABLE);
 923:stm32f429i_discovery_ioe.c **** 
 924:stm32f429i_discovery_ioe.c ****   /* Connect PXx to I2C_SCL*/
 925:stm32f429i_discovery_ioe.c ****   GPIO_PinAFConfig(IOE_I2C_SCL_GPIO_PORT, IOE_I2C_SCL_SOURCE, IOE_I2C_SCL_AF);
  59              		.loc 1 925 0
  60 0022 0025     		movs	r5, #0
 920:stm32f429i_discovery_ioe.c ****   RCC_APB1PeriphResetCmd(IOE_I2C_CLK, ENABLE);
  61              		.loc 1 920 0
  62 0024 0121     		movs	r1, #1
  63 0026 4FF40000 		mov	r0, #8388608
  64 002a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  65              	.LVL3:
  66              		.loc 1 925 0
  67 002e C4F20205 		movt	r5, 16386
 922:stm32f429i_discovery_ioe.c ****   RCC_APB1PeriphResetCmd(IOE_I2C_CLK, DISABLE);
  68              		.loc 1 922 0
  69 0032 0021     		movs	r1, #0
  70 0034 4FF40000 		mov	r0, #8388608
 926:stm32f429i_discovery_ioe.c ****   /* Connect PXx to I2C_SDA*/
 927:stm32f429i_discovery_ioe.c ****   GPIO_PinAFConfig(IOE_I2C_SDA_GPIO_PORT, IOE_I2C_SDA_SOURCE, IOE_I2C_SDA_AF); 
  71              		.loc 1 927 0
  72 0038 4FF40064 		mov	r4, #2048
 922:stm32f429i_discovery_ioe.c ****   RCC_APB1PeriphResetCmd(IOE_I2C_CLK, DISABLE);
  73              		.loc 1 922 0
  74 003c FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  75              	.LVL4:
  76              		.loc 1 927 0
  77 0040 C4F20204 		movt	r4, 16386
 925:stm32f429i_discovery_ioe.c ****   GPIO_PinAFConfig(IOE_I2C_SCL_GPIO_PORT, IOE_I2C_SCL_SOURCE, IOE_I2C_SCL_AF);
  78              		.loc 1 925 0
  79 0044 2846     		mov	r0, r5
  80 0046 0821     		movs	r1, #8
  81 0048 0422     		movs	r2, #4
  82 004a FFF7FEFF 		bl	GPIO_PinAFConfig
  83              	.LVL5:
  84              		.loc 1 927 0
  85 004e 2046     		mov	r0, r4
  86 0050 0921     		movs	r1, #9
  87 0052 0422     		movs	r2, #4
  88 0054 FFF7FEFF 		bl	GPIO_PinAFConfig
  89              	.LVL6:
 928:stm32f429i_discovery_ioe.c ****     
 929:stm32f429i_discovery_ioe.c ****   /* IOE_I2C SCL and SDA pins configuration */
 930:stm32f429i_discovery_ioe.c ****   GPIO_InitStructure.GPIO_Pin = IOE_I2C_SCL_PIN;
 931:stm32f429i_discovery_ioe.c ****   GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  90              		.loc 1 931 0
  91 0058 0223     		movs	r3, #2
 930:stm32f429i_discovery_ioe.c ****   GPIO_InitStructure.GPIO_Pin = IOE_I2C_SCL_PIN;
  92              		.loc 1 930 0
  93 005a 4FF48072 		mov	r2, #256
 932:stm32f429i_discovery_ioe.c ****   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 933:stm32f429i_discovery_ioe.c ****   GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 934:stm32f429i_discovery_ioe.c ****   GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 935:stm32f429i_discovery_ioe.c ****   GPIO_Init(IOE_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
  94              		.loc 1 935 0
  95 005e 2846     		mov	r0, r5
  96 0060 6946     		mov	r1, sp
 930:stm32f429i_discovery_ioe.c ****   GPIO_InitStructure.GPIO_Pin = IOE_I2C_SCL_PIN;
  97              		.loc 1 930 0
  98 0062 0092     		str	r2, [sp, #0]
 931:stm32f429i_discovery_ioe.c ****   GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  99              		.loc 1 931 0
 100 0064 8DF80430 		strb	r3, [sp, #4]
 932:stm32f429i_discovery_ioe.c ****   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 101              		.loc 1 932 0
 102 0068 8DF80530 		strb	r3, [sp, #5]
 934:stm32f429i_discovery_ioe.c ****   GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 103              		.loc 1 934 0
 104 006c 0022     		movs	r2, #0
 933:stm32f429i_discovery_ioe.c ****   GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 105              		.loc 1 933 0
 106 006e 0123     		movs	r3, #1
 107 0070 8DF80630 		strb	r3, [sp, #6]
 934:stm32f429i_discovery_ioe.c ****   GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 108              		.loc 1 934 0
 109 0074 8DF80720 		strb	r2, [sp, #7]
 110              		.loc 1 935 0
 111 0078 FFF7FEFF 		bl	GPIO_Init
 112              	.LVL7:
 936:stm32f429i_discovery_ioe.c **** 
 937:stm32f429i_discovery_ioe.c ****   GPIO_InitStructure.GPIO_Pin = IOE_I2C_SDA_PIN;
 113              		.loc 1 937 0
 114 007c 4FF40073 		mov	r3, #512
 938:stm32f429i_discovery_ioe.c ****   GPIO_Init(IOE_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
 115              		.loc 1 938 0
 116 0080 2046     		mov	r0, r4
 117 0082 6946     		mov	r1, sp
 937:stm32f429i_discovery_ioe.c ****   GPIO_InitStructure.GPIO_Pin = IOE_I2C_SDA_PIN;
 118              		.loc 1 937 0
 119 0084 0093     		str	r3, [sp, #0]
 120              		.loc 1 938 0
 121 0086 FFF7FEFF 		bl	GPIO_Init
 122              	.LVL8:
 939:stm32f429i_discovery_ioe.c ****   
 940:stm32f429i_discovery_ioe.c **** }
 123              		.loc 1 940 0
 124 008a 03B0     		add	sp, sp, #12
 125 008c 30BD     		pop	{r4, r5, pc}
 126              		.cfi_endproc
 127              	.LFE131:
 129 008e 00BF     		.section	.text.IOE_DMA_Config,"ax",%progbits
 130              		.align	2
 131              		.p2align 4,,15
 132              		.thumb
 133              		.thumb_func
 135              	IOE_DMA_Config:
 136              	.LFB133:
 941:stm32f429i_discovery_ioe.c **** 
 942:stm32f429i_discovery_ioe.c **** /**
 943:stm32f429i_discovery_ioe.c ****   * @brief  Configure the I2C Peripheral used to communicate with IO_Expanders.
 944:stm32f429i_discovery_ioe.c ****   * @param  None
 945:stm32f429i_discovery_ioe.c ****   * @retval None
 946:stm32f429i_discovery_ioe.c ****   */
 947:stm32f429i_discovery_ioe.c **** static void IOE_I2C_Config(void)
 948:stm32f429i_discovery_ioe.c **** {
 949:stm32f429i_discovery_ioe.c ****   I2C_InitTypeDef I2C_InitStructure;
 950:stm32f429i_discovery_ioe.c **** 
 951:stm32f429i_discovery_ioe.c ****   /* If the I2C peripheral is already enabled, don't reconfigure it */
 952:stm32f429i_discovery_ioe.c ****   if ((IOE_I2C->CR1 & I2C_CR1_PE) == 0)
 953:stm32f429i_discovery_ioe.c ****   {   
 954:stm32f429i_discovery_ioe.c ****     /* IOE_I2C configuration */
 955:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 956:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 957:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 958:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 959:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 960:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
 961:stm32f429i_discovery_ioe.c ****   
 962:stm32f429i_discovery_ioe.c ****     /* Initialize the I2C peripheral */
 963:stm32f429i_discovery_ioe.c ****     I2C_Init(IOE_I2C, &I2C_InitStructure);
 964:stm32f429i_discovery_ioe.c ****   
 965:stm32f429i_discovery_ioe.c ****     /* Enable the I2C peripheral */
 966:stm32f429i_discovery_ioe.c ****     I2C_Cmd(IOE_I2C, ENABLE);
 967:stm32f429i_discovery_ioe.c ****   }   
 968:stm32f429i_discovery_ioe.c **** }
 969:stm32f429i_discovery_ioe.c **** 
 970:stm32f429i_discovery_ioe.c **** /**
 971:stm32f429i_discovery_ioe.c ****   * @brief  Configure the DMA Peripheral used to handle communication via I2C.
 972:stm32f429i_discovery_ioe.c ****   * @param  None
 973:stm32f429i_discovery_ioe.c ****   * @retval None
 974:stm32f429i_discovery_ioe.c ****   */
 975:stm32f429i_discovery_ioe.c **** static void IOE_DMA_Config(IOE_DMADirection_TypeDef Direction, uint8_t* buffer)
 976:stm32f429i_discovery_ioe.c **** {
 137              		.loc 1 976 0
 138              		.cfi_startproc
 139              		@ args = 0, pretend = 0, frame = 64
 140              		@ frame_needed = 0, uses_anonymous_args = 0
 141              	.LVL9:
 142 0000 30B5     		push	{r4, r5, lr}
 143              	.LCFI2:
 144              		.cfi_def_cfa_offset 12
 145              		.cfi_offset 4, -12
 146              		.cfi_offset 5, -8
 147              		.cfi_offset 14, -4
 148 0002 0D46     		mov	r5, r1
 149 0004 91B0     		sub	sp, sp, #68
 150              	.LCFI3:
 151              		.cfi_def_cfa_offset 80
 977:stm32f429i_discovery_ioe.c ****   DMA_InitTypeDef DMA_InitStructure;
 978:stm32f429i_discovery_ioe.c ****   
 979:stm32f429i_discovery_ioe.c ****   RCC_AHB1PeriphClockCmd(IOE_DMA_CLK, ENABLE);
 152              		.loc 1 979 0
 153 0006 0121     		movs	r1, #1
 154              	.LVL10:
 976:stm32f429i_discovery_ioe.c **** {
 155              		.loc 1 976 0
 156 0008 0446     		mov	r4, r0
 157              		.loc 1 979 0
 158 000a 4FF40010 		mov	r0, #2097152
 159              	.LVL11:
 160 000e FFF7FEFF 		bl	RCC_AHB1PeriphClockCmd
 161              	.LVL12:
 980:stm32f429i_discovery_ioe.c ****   
 981:stm32f429i_discovery_ioe.c ****   /* Initialize the DMA_Channel member */
 982:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_Channel = IOE_DMA_CHANNEL;
 983:stm32f429i_discovery_ioe.c ****   
 984:stm32f429i_discovery_ioe.c ****   /* Initialize the DMA_PeripheralBaseAddr member */
 985:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_PeripheralBaseAddr = IOE_I2C_DR;
 162              		.loc 1 985 0
 163 0012 45F61042 		movw	r2, #23568
 164 0016 C4F20002 		movt	r2, 16384
 986:stm32f429i_discovery_ioe.c ****   
 987:stm32f429i_discovery_ioe.c ****   /* Initialize the DMA_Memory0BaseAddr member */
 988:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)buffer;
 989:stm32f429i_discovery_ioe.c ****   
 990:stm32f429i_discovery_ioe.c ****   /* Initialize the DMA_PeripheralInc member */
 991:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 165              		.loc 1 991 0
 166 001a 0023     		movs	r3, #0
 982:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_Channel = IOE_DMA_CHANNEL;
 167              		.loc 1 982 0
 168 001c 4FF00071 		mov	r1, #33554432
 985:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_PeripheralBaseAddr = IOE_I2C_DR;
 169              		.loc 1 985 0
 170 0020 0292     		str	r2, [sp, #8]
 992:stm32f429i_discovery_ioe.c ****   
 993:stm32f429i_discovery_ioe.c ****   /* Initialize the DMA_MemoryInc member */
 994:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 171              		.loc 1 994 0
 172 0022 4FF48060 		mov	r0, #1024
 995:stm32f429i_discovery_ioe.c ****   
 996:stm32f429i_discovery_ioe.c ****   /* Initialize the DMA_PeripheralDataSize member */
 997:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 998:stm32f429i_discovery_ioe.c ****   
 999:stm32f429i_discovery_ioe.c ****   /* Initialize the DMA_MemoryDataSize member */
1000:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
1001:stm32f429i_discovery_ioe.c ****   
1002:stm32f429i_discovery_ioe.c ****   /* Initialize the DMA_Mode member */
1003:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
1004:stm32f429i_discovery_ioe.c ****   
1005:stm32f429i_discovery_ioe.c ****   /* Initialize the DMA_Priority member */
1006:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_Priority = DMA_Priority_Low;
1007:stm32f429i_discovery_ioe.c ****   
1008:stm32f429i_discovery_ioe.c ****   /* Initialize the DMA_FIFOMode member */
1009:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;
 173              		.loc 1 1009 0
 174 0026 0422     		movs	r2, #4
1010:stm32f429i_discovery_ioe.c ****   
1011:stm32f429i_discovery_ioe.c ****   /* Initialize the DMA_FIFOThreshold member */
1012:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
1013:stm32f429i_discovery_ioe.c ****   
1014:stm32f429i_discovery_ioe.c ****   /* Initialize the DMA_MemoryBurst member */
1015:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
1016:stm32f429i_discovery_ioe.c ****   
1017:stm32f429i_discovery_ioe.c ****   /* Initialize the DMA_PeripheralBurst member */
1018:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
1019:stm32f429i_discovery_ioe.c ****   
1020:stm32f429i_discovery_ioe.c ****   /* If using DMA for Reception */
1021:stm32f429i_discovery_ioe.c ****   if (Direction == IOE_DMA_RX)
 175              		.loc 1 1021 0
 176 0028 012C     		cmp	r4, #1
 982:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_Channel = IOE_DMA_CHANNEL;
 177              		.loc 1 982 0
 178 002a 0191     		str	r1, [sp, #4]
 988:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)buffer;
 179              		.loc 1 988 0
 180 002c 0395     		str	r5, [sp, #12]
 991:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 181              		.loc 1 991 0
 182 002e 0693     		str	r3, [sp, #24]
 994:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 183              		.loc 1 994 0
 184 0030 0790     		str	r0, [sp, #28]
 997:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 185              		.loc 1 997 0
 186 0032 0893     		str	r3, [sp, #32]
1000:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 187              		.loc 1 1000 0
 188 0034 0993     		str	r3, [sp, #36]
1003:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 189              		.loc 1 1003 0
 190 0036 0A93     		str	r3, [sp, #40]
1006:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_Priority = DMA_Priority_Low;
 191              		.loc 1 1006 0
 192 0038 0B93     		str	r3, [sp, #44]
1009:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;
 193              		.loc 1 1009 0
 194 003a 0C92     		str	r2, [sp, #48]
1012:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
 195              		.loc 1 1012 0
 196 003c 0D93     		str	r3, [sp, #52]
1015:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
 197              		.loc 1 1015 0
 198 003e 0E93     		str	r3, [sp, #56]
1018:stm32f429i_discovery_ioe.c ****   DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 199              		.loc 1 1018 0
 200 0040 0F93     		str	r3, [sp, #60]
 201              		.loc 1 1021 0
 202 0042 13D0     		beq	.L6
1022:stm32f429i_discovery_ioe.c ****   {    
1023:stm32f429i_discovery_ioe.c ****     /* Initialize the DMA_DIR member */
1024:stm32f429i_discovery_ioe.c ****     DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
1025:stm32f429i_discovery_ioe.c ****     
1026:stm32f429i_discovery_ioe.c ****     /* Initialize the DMA_BufferSize member */
1027:stm32f429i_discovery_ioe.c ****     DMA_InitStructure.DMA_BufferSize = 2;
1028:stm32f429i_discovery_ioe.c ****     
1029:stm32f429i_discovery_ioe.c ****     DMA_DeInit(IOE_DMA_RX_STREAM);
1030:stm32f429i_discovery_ioe.c ****     
1031:stm32f429i_discovery_ioe.c ****     DMA_Init(IOE_DMA_RX_STREAM, &DMA_InitStructure);
1032:stm32f429i_discovery_ioe.c ****   }
1033:stm32f429i_discovery_ioe.c ****   /* If using DMA for Transmission */
1034:stm32f429i_discovery_ioe.c ****   else if (Direction == IOE_DMA_TX)
 203              		.loc 1 1034 0
 204 0044 84B9     		cbnz	r4, .L2
1035:stm32f429i_discovery_ioe.c ****   { 
1036:stm32f429i_discovery_ioe.c ****     /* Initialize the DMA_DIR member */
1037:stm32f429i_discovery_ioe.c ****     DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
1038:stm32f429i_discovery_ioe.c ****     
1039:stm32f429i_discovery_ioe.c ****     /* Initialize the DMA_BufferSize member */
1040:stm32f429i_discovery_ioe.c ****     DMA_InitStructure.DMA_BufferSize = 1;
1041:stm32f429i_discovery_ioe.c ****     
1042:stm32f429i_discovery_ioe.c ****     DMA_DeInit(IOE_DMA_TX_STREAM);
 205              		.loc 1 1042 0
 206 0046 46F2A000 		movw	r0, #24736
1040:stm32f429i_discovery_ioe.c ****     DMA_InitStructure.DMA_BufferSize = 1;
 207              		.loc 1 1040 0
 208 004a 0121     		movs	r1, #1
 209              		.loc 1 1042 0
 210 004c C4F20200 		movt	r0, 16386
1037:stm32f429i_discovery_ioe.c ****     DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
 211              		.loc 1 1037 0
 212 0050 4023     		movs	r3, #64
1040:stm32f429i_discovery_ioe.c ****     DMA_InitStructure.DMA_BufferSize = 1;
 213              		.loc 1 1040 0
 214 0052 0591     		str	r1, [sp, #20]
1037:stm32f429i_discovery_ioe.c ****     DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
 215              		.loc 1 1037 0
 216 0054 0493     		str	r3, [sp, #16]
 217              		.loc 1 1042 0
 218 0056 FFF7FEFF 		bl	DMA_DeInit
 219              	.LVL13:
1043:stm32f429i_discovery_ioe.c ****     
1044:stm32f429i_discovery_ioe.c ****     DMA_Init(IOE_DMA_TX_STREAM, &DMA_InitStructure);
 220              		.loc 1 1044 0
 221 005a 46F2A000 		movw	r0, #24736
 222 005e C4F20200 		movt	r0, 16386
 223 0062 01A9     		add	r1, sp, #4
 224 0064 FFF7FEFF 		bl	DMA_Init
 225              	.LVL14:
 226              	.L2:
1045:stm32f429i_discovery_ioe.c ****   }
1046:stm32f429i_discovery_ioe.c **** }
 227              		.loc 1 1046 0
 228 0068 11B0     		add	sp, sp, #68
 229 006a 30BD     		pop	{r4, r5, pc}
 230              	.L6:
1029:stm32f429i_discovery_ioe.c ****     DMA_DeInit(IOE_DMA_RX_STREAM);
 231              		.loc 1 1029 0
 232 006c 46F21000 		movw	r0, #24592
1027:stm32f429i_discovery_ioe.c ****     DMA_InitStructure.DMA_BufferSize = 2;
 233              		.loc 1 1027 0
 234 0070 0222     		movs	r2, #2
1029:stm32f429i_discovery_ioe.c ****     DMA_DeInit(IOE_DMA_RX_STREAM);
 235              		.loc 1 1029 0
 236 0072 C4F20200 		movt	r0, 16386
1024:stm32f429i_discovery_ioe.c ****     DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
 237              		.loc 1 1024 0
 238 0076 0493     		str	r3, [sp, #16]
1027:stm32f429i_discovery_ioe.c ****     DMA_InitStructure.DMA_BufferSize = 2;
 239              		.loc 1 1027 0
 240 0078 0592     		str	r2, [sp, #20]
1029:stm32f429i_discovery_ioe.c ****     DMA_DeInit(IOE_DMA_RX_STREAM);
 241              		.loc 1 1029 0
 242 007a FFF7FEFF 		bl	DMA_DeInit
 243              	.LVL15:
1031:stm32f429i_discovery_ioe.c ****     DMA_Init(IOE_DMA_RX_STREAM, &DMA_InitStructure);
 244              		.loc 1 1031 0
 245 007e 46F21000 		movw	r0, #24592
 246 0082 C4F20200 		movt	r0, 16386
 247 0086 01A9     		add	r1, sp, #4
 248 0088 FFF7FEFF 		bl	DMA_Init
 249              	.LVL16:
 250 008c ECE7     		b	.L2
 251              		.cfi_endproc
 252              	.LFE133:
 254 008e 00BF     		.section	.text.IOE_TimeoutUserCallback,"ax",%progbits
 255              		.align	2
 256              		.p2align 4,,15
 257              		.global	IOE_TimeoutUserCallback
 258              		.thumb
 259              		.thumb_func
 261              	IOE_TimeoutUserCallback:
 262              	.LFB137:
1047:stm32f429i_discovery_ioe.c **** 
1048:stm32f429i_discovery_ioe.c **** /**
1049:stm32f429i_discovery_ioe.c ****   * @brief  Writes a value in a register of the device through I2C.
1050:stm32f429i_discovery_ioe.c ****   * @param  RegisterAddr: The target register address
1051:stm32f429i_discovery_ioe.c ****   * @param  RegisterValue: The target register value to be written 
1052:stm32f429i_discovery_ioe.c ****   * @retval IOE_OK: if all operations are OK. Other value if error.
1053:stm32f429i_discovery_ioe.c ****   */
1054:stm32f429i_discovery_ioe.c **** uint8_t I2C_WriteDeviceRegister(uint8_t RegisterAddr, uint8_t RegisterValue)
1055:stm32f429i_discovery_ioe.c **** {
1056:stm32f429i_discovery_ioe.c ****   uint32_t read_verif = 0;
1057:stm32f429i_discovery_ioe.c **** 
1058:stm32f429i_discovery_ioe.c ****   /* Begin the configuration sequence */
1059:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
1060:stm32f429i_discovery_ioe.c **** 
1061:stm32f429i_discovery_ioe.c ****   /* Test on EV5 and clear it */
1062:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1063:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
1064:stm32f429i_discovery_ioe.c ****   {
1065:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1066:stm32f429i_discovery_ioe.c ****   }
1067:stm32f429i_discovery_ioe.c **** 
1068:stm32f429i_discovery_ioe.c ****   /* Transmit the slave address and enable writing operation */
1069:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Transmitter);
1070:stm32f429i_discovery_ioe.c ****   
1071:stm32f429i_discovery_ioe.c ****   /* Test on EV6 and clear it */
1072:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;  
1073:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
1074:stm32f429i_discovery_ioe.c ****   {
1075:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1076:stm32f429i_discovery_ioe.c ****   }
1077:stm32f429i_discovery_ioe.c ****   
1078:stm32f429i_discovery_ioe.c ****   /* Read status register 2 to clear ADDR flag */
1079:stm32f429i_discovery_ioe.c ****   IOE_I2C->SR2;
1080:stm32f429i_discovery_ioe.c ****   
1081:stm32f429i_discovery_ioe.c ****   /* Test on EV8_1 and clear it */
1082:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1083:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE))
1084:stm32f429i_discovery_ioe.c ****   {
1085:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1086:stm32f429i_discovery_ioe.c ****   }
1087:stm32f429i_discovery_ioe.c ****   
1088:stm32f429i_discovery_ioe.c ****   /* Transmit the first address for r/w operations */
1089:stm32f429i_discovery_ioe.c ****   I2C_SendData(IOE_I2C, RegisterAddr);
1090:stm32f429i_discovery_ioe.c ****   
1091:stm32f429i_discovery_ioe.c ****   /* Test on EV8 and clear it */
1092:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1093:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE))
1094:stm32f429i_discovery_ioe.c ****   {
1095:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1096:stm32f429i_discovery_ioe.c ****   }
1097:stm32f429i_discovery_ioe.c ****   
1098:stm32f429i_discovery_ioe.c ****   /* Prepare the register value to be sent */
1099:stm32f429i_discovery_ioe.c ****   I2C_SendData(IOE_I2C, RegisterValue);
1100:stm32f429i_discovery_ioe.c ****   
1101:stm32f429i_discovery_ioe.c ****   /* Test on EV8_2 and clear it */
1102:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1103:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE)) || (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_BTF))
1104:stm32f429i_discovery_ioe.c ****   {
1105:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1106:stm32f429i_discovery_ioe.c ****   }
1107:stm32f429i_discovery_ioe.c ****   
1108:stm32f429i_discovery_ioe.c ****   /* End the configuration sequence */
1109:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTOP(IOE_I2C, ENABLE);
1110:stm32f429i_discovery_ioe.c ****   
1111:stm32f429i_discovery_ioe.c **** #ifdef VERIFY_WRITTENDATA
1112:stm32f429i_discovery_ioe.c ****   /* Verify (if needed) that the loaded data is correct  */
1113:stm32f429i_discovery_ioe.c ****   
1114:stm32f429i_discovery_ioe.c ****   /* Read the just written register*/
1115:stm32f429i_discovery_ioe.c ****   read_verif = IOE_I2C_ReadDeviceRegister(RegisterAddr);
1116:stm32f429i_discovery_ioe.c **** 
1117:stm32f429i_discovery_ioe.c ****   /* Load the register and verify its value  */
1118:stm32f429i_discovery_ioe.c ****   if (read_verif != RegisterValue)
1119:stm32f429i_discovery_ioe.c ****   {
1120:stm32f429i_discovery_ioe.c ****     /* Control data wrongly transferred */
1121:stm32f429i_discovery_ioe.c ****     read_verif = IOE_FAILURE;
1122:stm32f429i_discovery_ioe.c ****   }
1123:stm32f429i_discovery_ioe.c ****   else
1124:stm32f429i_discovery_ioe.c ****   {
1125:stm32f429i_discovery_ioe.c ****     /* Control data correctly transferred */
1126:stm32f429i_discovery_ioe.c ****     read_verif = 0;
1127:stm32f429i_discovery_ioe.c ****   }
1128:stm32f429i_discovery_ioe.c **** #endif
1129:stm32f429i_discovery_ioe.c ****   
1130:stm32f429i_discovery_ioe.c ****   /* Return the verifying value: 0 (Passed) or 1 (Failed) */
1131:stm32f429i_discovery_ioe.c ****   return read_verif;
1132:stm32f429i_discovery_ioe.c ****   
1133:stm32f429i_discovery_ioe.c **** }
1134:stm32f429i_discovery_ioe.c **** 
1135:stm32f429i_discovery_ioe.c **** /**
1136:stm32f429i_discovery_ioe.c ****   * @brief  Reads a register of the device through I2C without DMA.
1137:stm32f429i_discovery_ioe.c ****   * @param  RegisterAddr: The target register address (between 00x and 0x24)
1138:stm32f429i_discovery_ioe.c ****   * @retval The value of the read register (0xAA if Timeout occurred)   
1139:stm32f429i_discovery_ioe.c ****   */ 
1140:stm32f429i_discovery_ioe.c **** uint8_t I2C_ReadDeviceRegister(uint8_t RegisterAddr)
1141:stm32f429i_discovery_ioe.c **** {
1142:stm32f429i_discovery_ioe.c ****   uint8_t tmp = 0;
1143:stm32f429i_discovery_ioe.c ****   
1144:stm32f429i_discovery_ioe.c ****   /* Enable the I2C peripheral */
1145:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
1146:stm32f429i_discovery_ioe.c ****   
1147:stm32f429i_discovery_ioe.c ****     /* Test on EV5 and clear it */
1148:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1149:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
1150:stm32f429i_discovery_ioe.c ****   {
1151:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1152:stm32f429i_discovery_ioe.c ****   }
1153:stm32f429i_discovery_ioe.c ****   /* Disable Acknowledgement */
1154:stm32f429i_discovery_ioe.c ****   I2C_AcknowledgeConfig(IOE_I2C, DISABLE);
1155:stm32f429i_discovery_ioe.c ****   
1156:stm32f429i_discovery_ioe.c ****   /* Transmit the slave address and enable writing operation */
1157:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Transmitter);
1158:stm32f429i_discovery_ioe.c ****   
1159:stm32f429i_discovery_ioe.c ****   /* Test on EV6 and clear it */
1160:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;  
1161:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
1162:stm32f429i_discovery_ioe.c ****   {
1163:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1164:stm32f429i_discovery_ioe.c ****   }
1165:stm32f429i_discovery_ioe.c ****   
1166:stm32f429i_discovery_ioe.c ****   /* Read status register 2 to clear ADDR flag */
1167:stm32f429i_discovery_ioe.c ****   IOE_I2C->SR2;
1168:stm32f429i_discovery_ioe.c ****   
1169:stm32f429i_discovery_ioe.c ****   /* Test on EV8 and clear it */
1170:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1171:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE))
1172:stm32f429i_discovery_ioe.c ****   {
1173:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1174:stm32f429i_discovery_ioe.c ****   }
1175:stm32f429i_discovery_ioe.c ****   
1176:stm32f429i_discovery_ioe.c ****   /* Transmit the first address for r/w operations */
1177:stm32f429i_discovery_ioe.c ****   I2C_SendData(IOE_I2C, RegisterAddr);
1178:stm32f429i_discovery_ioe.c ****   
1179:stm32f429i_discovery_ioe.c ****   /* Test on EV8 and clear it */
1180:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1181:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE)) || (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_BTF))
1182:stm32f429i_discovery_ioe.c ****   {
1183:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1184:stm32f429i_discovery_ioe.c ****   }
1185:stm32f429i_discovery_ioe.c ****   
1186:stm32f429i_discovery_ioe.c ****   /* Regenerate a start condition */
1187:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
1188:stm32f429i_discovery_ioe.c ****   
1189:stm32f429i_discovery_ioe.c ****   /* Test on EV5 and clear it */
1190:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1191:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
1192:stm32f429i_discovery_ioe.c ****   {
1193:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1194:stm32f429i_discovery_ioe.c ****   }
1195:stm32f429i_discovery_ioe.c ****   
1196:stm32f429i_discovery_ioe.c ****   /* Transmit the slave address and enable writing operation */
1197:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Receiver);
1198:stm32f429i_discovery_ioe.c ****   
1199:stm32f429i_discovery_ioe.c ****   /* Test on EV6 and clear it */
1200:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1201:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
1202:stm32f429i_discovery_ioe.c ****   {
1203:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1204:stm32f429i_discovery_ioe.c ****   }
1205:stm32f429i_discovery_ioe.c ****   
1206:stm32f429i_discovery_ioe.c ****     /* Read status register 2 to clear ADDR flag */
1207:stm32f429i_discovery_ioe.c ****   IOE_I2C->SR2;
1208:stm32f429i_discovery_ioe.c ****   
1209:stm32f429i_discovery_ioe.c ****   /* Test on EV7 and clear it */
1210:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1211:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_RXNE))
1212:stm32f429i_discovery_ioe.c ****   {
1213:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1214:stm32f429i_discovery_ioe.c ****   }
1215:stm32f429i_discovery_ioe.c ****   
1216:stm32f429i_discovery_ioe.c ****   /* End the configuration sequence */
1217:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTOP(IOE_I2C, ENABLE);
1218:stm32f429i_discovery_ioe.c ****   
1219:stm32f429i_discovery_ioe.c ****   /* Load the register value */
1220:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReceiveData(IOE_I2C);
1221:stm32f429i_discovery_ioe.c ****   
1222:stm32f429i_discovery_ioe.c ****   /* Enable Acknowledgement */
1223:stm32f429i_discovery_ioe.c ****   I2C_AcknowledgeConfig(IOE_I2C, ENABLE);
1224:stm32f429i_discovery_ioe.c ****   
1225:stm32f429i_discovery_ioe.c ****   /* Return the read value */
1226:stm32f429i_discovery_ioe.c ****   return tmp;
1227:stm32f429i_discovery_ioe.c ****   
1228:stm32f429i_discovery_ioe.c **** }
1229:stm32f429i_discovery_ioe.c **** 
1230:stm32f429i_discovery_ioe.c **** /**
1231:stm32f429i_discovery_ioe.c ****   * @brief  Reads a buffer of 2 bytes from the device registers.
1232:stm32f429i_discovery_ioe.c ****   * @param  RegisterAddr: The target register adress (between 00x and 0x24)
1233:stm32f429i_discovery_ioe.c ****   * @retval The data in the buffer containing the two returned bytes (in halfword).   
1234:stm32f429i_discovery_ioe.c ****   */
1235:stm32f429i_discovery_ioe.c **** uint16_t I2C_ReadDataBuffer(uint32_t RegisterAddr)
1236:stm32f429i_discovery_ioe.c **** {
1237:stm32f429i_discovery_ioe.c ****   uint8_t IOE_BufferRX[2] = {0x00, 0x00};  
1238:stm32f429i_discovery_ioe.c ****   
1239:stm32f429i_discovery_ioe.c ****   /* Enable the I2C peripheral */
1240:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
1241:stm32f429i_discovery_ioe.c ****  
1242:stm32f429i_discovery_ioe.c ****   /* Test on EV5 and clear it */
1243:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1244:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
1245:stm32f429i_discovery_ioe.c ****   {
1246:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1247:stm32f429i_discovery_ioe.c ****   }
1248:stm32f429i_discovery_ioe.c ****    
1249:stm32f429i_discovery_ioe.c ****   /* Send device address for write */
1250:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Transmitter);
1251:stm32f429i_discovery_ioe.c ****   
1252:stm32f429i_discovery_ioe.c ****   /* Test on EV6 and clear it */
1253:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;  
1254:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
1255:stm32f429i_discovery_ioe.c ****   {
1256:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1257:stm32f429i_discovery_ioe.c ****   }
1258:stm32f429i_discovery_ioe.c ****   
1259:stm32f429i_discovery_ioe.c ****   /* Read status register 2 to clear ADDR flag */
1260:stm32f429i_discovery_ioe.c ****   IOE_I2C->SR2;
1261:stm32f429i_discovery_ioe.c ****   
1262:stm32f429i_discovery_ioe.c ****   /* Test on EV8 and clear it */
1263:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1264:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE))
1265:stm32f429i_discovery_ioe.c ****   {
1266:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1267:stm32f429i_discovery_ioe.c ****   }
1268:stm32f429i_discovery_ioe.c ****   
1269:stm32f429i_discovery_ioe.c ****   /* Send the device's internal address to write to */
1270:stm32f429i_discovery_ioe.c ****   I2C_SendData(IOE_I2C, RegisterAddr);  
1271:stm32f429i_discovery_ioe.c ****     
1272:stm32f429i_discovery_ioe.c ****   /* Send START condition a second time */  
1273:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
1274:stm32f429i_discovery_ioe.c ****   
1275:stm32f429i_discovery_ioe.c ****   /* Test on EV5 and clear it */
1276:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1277:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
1278:stm32f429i_discovery_ioe.c ****   {
1279:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1280:stm32f429i_discovery_ioe.c ****   }
1281:stm32f429i_discovery_ioe.c ****   
1282:stm32f429i_discovery_ioe.c ****   /* Send IO Expander address for read */
1283:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Receiver);
1284:stm32f429i_discovery_ioe.c ****   
1285:stm32f429i_discovery_ioe.c ****   /* Test on EV6 and clear it */
1286:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1287:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
1288:stm32f429i_discovery_ioe.c ****   {
1289:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1290:stm32f429i_discovery_ioe.c ****   }
1291:stm32f429i_discovery_ioe.c ****  
1292:stm32f429i_discovery_ioe.c ****   /* Disable Acknowledgement and set Pos bit */
1293:stm32f429i_discovery_ioe.c ****   I2C_AcknowledgeConfig(IOE_I2C, DISABLE);       
1294:stm32f429i_discovery_ioe.c ****   I2C_NACKPositionConfig(IOE_I2C, I2C_NACKPosition_Next);
1295:stm32f429i_discovery_ioe.c ****   
1296:stm32f429i_discovery_ioe.c ****   /* Read status register 2 to clear ADDR flag */
1297:stm32f429i_discovery_ioe.c ****   IOE_I2C->SR2;
1298:stm32f429i_discovery_ioe.c **** 
1299:stm32f429i_discovery_ioe.c ****   /* Test on EV7 and clear it */
1300:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
1301:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_BTF))
1302:stm32f429i_discovery_ioe.c ****   {
1303:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
1304:stm32f429i_discovery_ioe.c ****   }
1305:stm32f429i_discovery_ioe.c ****  
1306:stm32f429i_discovery_ioe.c ****   /* Send STOP Condition */
1307:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTOP(IOE_I2C, ENABLE);
1308:stm32f429i_discovery_ioe.c ****    
1309:stm32f429i_discovery_ioe.c ****   /* Read the first byte from the IO Expander */
1310:stm32f429i_discovery_ioe.c ****   IOE_BufferRX[1] = I2C_ReceiveData(IOE_I2C);
1311:stm32f429i_discovery_ioe.c ****     
1312:stm32f429i_discovery_ioe.c ****   /* Read the second byte from the IO Expander */
1313:stm32f429i_discovery_ioe.c ****   IOE_BufferRX[0] = I2C_ReceiveData(IOE_I2C);
1314:stm32f429i_discovery_ioe.c ****                                          
1315:stm32f429i_discovery_ioe.c ****   /* Enable Acknowledgement and reset POS bit to be ready for another reception */
1316:stm32f429i_discovery_ioe.c ****   I2C_AcknowledgeConfig(IOE_I2C, ENABLE);
1317:stm32f429i_discovery_ioe.c ****   I2C_NACKPositionConfig(IOE_I2C, I2C_NACKPosition_Current);
1318:stm32f429i_discovery_ioe.c ****    
1319:stm32f429i_discovery_ioe.c ****   /* return the data */
1320:stm32f429i_discovery_ioe.c ****   return ((uint16_t) IOE_BufferRX[0] | ((uint16_t)IOE_BufferRX[1]<< 8));
1321:stm32f429i_discovery_ioe.c **** }
1322:stm32f429i_discovery_ioe.c **** 
1323:stm32f429i_discovery_ioe.c **** #ifndef USE_TIMEOUT_USER_CALLBACK 
1324:stm32f429i_discovery_ioe.c **** /**
1325:stm32f429i_discovery_ioe.c ****   * @brief  IOE_TIMEOUT_UserCallback
1326:stm32f429i_discovery_ioe.c ****   * @param  None
1327:stm32f429i_discovery_ioe.c ****   * @retval 0
1328:stm32f429i_discovery_ioe.c ****   */
1329:stm32f429i_discovery_ioe.c **** uint8_t IOE_TimeoutUserCallback(void)
1330:stm32f429i_discovery_ioe.c **** {
 263              		.loc 1 1330 0
 264              		.cfi_startproc
 265              		@ args = 0, pretend = 0, frame = 16
 266              		@ frame_needed = 0, uses_anonymous_args = 0
 267 0000 70B5     		push	{r4, r5, r6, lr}
 268              	.LCFI4:
 269              		.cfi_def_cfa_offset 16
 270              		.cfi_offset 4, -16
 271              		.cfi_offset 5, -12
 272              		.cfi_offset 6, -8
 273              		.cfi_offset 14, -4
1331:stm32f429i_discovery_ioe.c ****   I2C_InitTypeDef I2C_InitStructure;
1332:stm32f429i_discovery_ioe.c **** 
1333:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTOP(IOE_I2C, ENABLE);
 274              		.loc 1 1333 0
 275 0002 4FF4B844 		mov	r4, #23552
 276 0006 C4F20004 		movt	r4, 16384
1330:stm32f429i_discovery_ioe.c **** {
 277              		.loc 1 1330 0
 278 000a 84B0     		sub	sp, sp, #16
 279              	.LCFI5:
 280              		.cfi_def_cfa_offset 32
 281              		.loc 1 1333 0
 282 000c 0121     		movs	r1, #1
 283 000e 2046     		mov	r0, r4
 284 0010 FFF7FEFF 		bl	I2C_GenerateSTOP
 285              	.LVL17:
1334:stm32f429i_discovery_ioe.c ****   I2C_SoftwareResetCmd(IOE_I2C, ENABLE);
 286              		.loc 1 1334 0
 287 0014 2046     		mov	r0, r4
 288 0016 0121     		movs	r1, #1
 289 0018 FFF7FEFF 		bl	I2C_SoftwareResetCmd
 290              	.LVL18:
1335:stm32f429i_discovery_ioe.c ****   I2C_SoftwareResetCmd(IOE_I2C, DISABLE);
 291              		.loc 1 1335 0
 292 001c 0021     		movs	r1, #0
 293 001e 2046     		mov	r0, r4
 294 0020 FFF7FEFF 		bl	I2C_SoftwareResetCmd
 295              	.LVL19:
1336:stm32f429i_discovery_ioe.c ****   
1337:stm32f429i_discovery_ioe.c ****   IOE_GPIO_Config();
 296              		.loc 1 1337 0
 297 0024 FFF7FEFF 		bl	IOE_GPIO_Config
 298              	.LVL20:
1338:stm32f429i_discovery_ioe.c **** 
1339:stm32f429i_discovery_ioe.c ****   /* CODEC_I2C peripheral configuration */
1340:stm32f429i_discovery_ioe.c ****   I2C_DeInit(IOE_I2C);
 299              		.loc 1 1340 0
 300 0028 2046     		mov	r0, r4
 301 002a FFF7FEFF 		bl	I2C_DeInit
 302              	.LVL21:
1341:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
1342:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
1343:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_OwnAddress1 = 0x00;
1344:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
1345:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 303              		.loc 1 1345 0
 304 002e 4FF48046 		mov	r6, #16384
1346:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
 305              		.loc 1 1346 0
 306 0032 04AD     		add	r5, sp, #16
 307 0034 48F2A063 		movw	r3, #34464
 308 0038 C0F20103 		movt	r3, 1
1347:stm32f429i_discovery_ioe.c ****   
1348:stm32f429i_discovery_ioe.c ****   /* Enable the I2C peripheral */
1349:stm32f429i_discovery_ioe.c ****   I2C_Cmd(IOE_I2C, ENABLE);  
 309              		.loc 1 1349 0
 310 003c 3004     		lsls	r0, r6, #16
1341:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 311              		.loc 1 1341 0
 312 003e 0024     		movs	r4, #0
1342:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 313              		.loc 1 1342 0
 314 0040 4BF6FF72 		movw	r2, #49151
1346:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
 315              		.loc 1 1346 0
 316 0044 45F8103D 		str	r3, [r5, #-16]!
 317              		.loc 1 1349 0
 318 0048 0121     		movs	r1, #1
1344:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 319              		.loc 1 1344 0
 320 004a 4FF48063 		mov	r3, #1024
 321              		.loc 1 1349 0
 322 004e 40F4B840 		orr	r0, r0, #23552
1342:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 323              		.loc 1 1342 0
 324 0052 ADF80620 		strh	r2, [sp, #6]	@ movhi
1344:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 325              		.loc 1 1344 0
 326 0056 ADF80A30 		strh	r3, [sp, #10]	@ movhi
1341:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 327              		.loc 1 1341 0
 328 005a ADF80440 		strh	r4, [sp, #4]	@ movhi
1343:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 329              		.loc 1 1343 0
 330 005e ADF80840 		strh	r4, [sp, #8]	@ movhi
1345:stm32f429i_discovery_ioe.c ****   I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 331              		.loc 1 1345 0
 332 0062 ADF80C60 		strh	r6, [sp, #12]	@ movhi
 333              		.loc 1 1349 0
 334 0066 FFF7FEFF 		bl	I2C_Cmd
 335              	.LVL22:
1350:stm32f429i_discovery_ioe.c ****   I2C_Init(IOE_I2C, &I2C_InitStructure);
 336              		.loc 1 1350 0
 337 006a 3104     		lsls	r1, r6, #16
 338 006c 41F4B840 		orr	r0, r1, #23552
 339 0070 6946     		mov	r1, sp
 340 0072 FFF7FEFF 		bl	I2C_Init
 341              	.LVL23:
1351:stm32f429i_discovery_ioe.c ****   
1352:stm32f429i_discovery_ioe.c ****   return 0;
1353:stm32f429i_discovery_ioe.c **** }
 342              		.loc 1 1353 0
 343 0076 2046     		mov	r0, r4
 344 0078 04B0     		add	sp, sp, #16
 345 007a 70BD     		pop	{r4, r5, r6, pc}
 346              		.cfi_endproc
 347              	.LFE137:
 349 007c AFF30080 		.section	.text.I2C_ReadDataBuffer,"ax",%progbits
 350              		.align	2
 351              		.p2align 4,,15
 352              		.global	I2C_ReadDataBuffer
 353              		.thumb
 354              		.thumb_func
 356              	I2C_ReadDataBuffer:
 357              	.LFB136:
1236:stm32f429i_discovery_ioe.c **** {
 358              		.loc 1 1236 0
 359              		.cfi_startproc
 360              		@ args = 0, pretend = 0, frame = 0
 361              		@ frame_needed = 0, uses_anonymous_args = 0
 362              	.LVL24:
 363 0000 70B5     		push	{r4, r5, r6, lr}
 364              	.LCFI6:
 365              		.cfi_def_cfa_offset 16
 366              		.cfi_offset 4, -16
 367              		.cfi_offset 5, -12
 368              		.cfi_offset 6, -8
 369              		.cfi_offset 14, -4
1236:stm32f429i_discovery_ioe.c **** {
 370              		.loc 1 1236 0
 371 0002 0646     		mov	r6, r0
1240:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 372              		.loc 1 1240 0
 373 0004 4FF4B840 		mov	r0, #23552
 374              	.LVL25:
 375 0008 C4F20000 		movt	r0, 16384
 376 000c 0121     		movs	r1, #1
1243:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 377              		.loc 1 1243 0
 378 000e 694C     		ldr	r4, .L30
1240:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 379              		.loc 1 1240 0
 380 0010 FFF7FEFF 		bl	I2C_GenerateSTART
 381              	.LVL26:
1243:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 382              		.loc 1 1243 0
 383 0014 4FF44053 		mov	r3, #12288
 384 0018 2360     		str	r3, [r4, #0]
1244:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
 385              		.loc 1 1244 0
 386 001a 05E0     		b	.L9
 387              	.L11:
1246:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 388              		.loc 1 1246 0
 389 001c 2368     		ldr	r3, [r4, #0]
 390 001e 581E     		subs	r0, r3, #1
 391 0020 2060     		str	r0, [r4, #0]
 392 0022 002B     		cmp	r3, #0
 393 0024 00F0C380 		beq	.L29
 394              	.L9:
1244:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
 395              		.loc 1 1244 0 discriminator 1
 396 0028 4FF4B840 		mov	r0, #23552
 397 002c 0121     		movs	r1, #1
 398 002e C4F20000 		movt	r0, 16384
 399 0032 C1F20001 		movt	r1, 4096
 400 0036 FFF7FEFF 		bl	I2C_GetFlagStatus
 401              	.LVL27:
 402 003a 0028     		cmp	r0, #0
 403 003c EED0     		beq	.L11
1250:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Transmitter);
 404              		.loc 1 1250 0
 405 003e 4FF4B840 		mov	r0, #23552
 406 0042 C4F20000 		movt	r0, 16384
 407 0046 8221     		movs	r1, #130
 408 0048 0022     		movs	r2, #0
 409 004a FFF7FEFF 		bl	I2C_Send7bitAddress
 410              	.LVL28:
1253:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;  
 411              		.loc 1 1253 0
 412 004e 4FF44050 		mov	r0, #12288
 413 0052 2060     		str	r0, [r4, #0]
1254:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
 414              		.loc 1 1254 0
 415 0054 05E0     		b	.L12
 416              	.L13:
1256:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 417              		.loc 1 1256 0
 418 0056 2168     		ldr	r1, [r4, #0]
 419 0058 4A1E     		subs	r2, r1, #1
 420 005a 2260     		str	r2, [r4, #0]
 421 005c 0029     		cmp	r1, #0
 422 005e 00F0A680 		beq	.L29
 423              	.L12:
1254:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
 424              		.loc 1 1254 0 discriminator 1
 425 0062 4FF4B845 		mov	r5, #23552
 426 0066 C4F20005 		movt	r5, 16384
 427 006a 0221     		movs	r1, #2
 428 006c 2846     		mov	r0, r5
 429 006e C1F20001 		movt	r1, 4096
 430 0072 FFF7FEFF 		bl	I2C_GetFlagStatus
 431              	.LVL29:
 432 0076 0028     		cmp	r0, #0
 433 0078 EDD0     		beq	.L13
 434              	.LVL30:
 435              	.LBB8:
 436              	.LBB9:
1263:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 437              		.loc 1 1263 0
 438 007a 4FF44051 		mov	r1, #12288
1260:stm32f429i_discovery_ioe.c ****   IOE_I2C->SR2;
 439              		.loc 1 1260 0
 440 007e 2B8B     		ldrh	r3, [r5, #24]
1263:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 441              		.loc 1 1263 0
 442 0080 2160     		str	r1, [r4, #0]
 443 0082 05E0     		b	.L14
 444              	.L16:
1266:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 445              		.loc 1 1266 0
 446 0084 2368     		ldr	r3, [r4, #0]
 447 0086 581E     		subs	r0, r3, #1
 448 0088 2060     		str	r0, [r4, #0]
 449 008a 002B     		cmp	r3, #0
 450 008c 00F08F80 		beq	.L29
 451              	.L14:
1264:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE))
 452              		.loc 1 1264 0
 453 0090 4FF4B840 		mov	r0, #23552
 454 0094 8021     		movs	r1, #128
 455 0096 C4F20000 		movt	r0, 16384
 456 009a C1F20001 		movt	r1, 4096
 457 009e FFF7FEFF 		bl	I2C_GetFlagStatus
 458              	.LVL31:
 459 00a2 0028     		cmp	r0, #0
 460 00a4 EED0     		beq	.L16
1270:stm32f429i_discovery_ioe.c ****   I2C_SendData(IOE_I2C, RegisterAddr);  
 461              		.loc 1 1270 0
 462 00a6 4FF4B840 		mov	r0, #23552
 463 00aa C4F20000 		movt	r0, 16384
 464 00ae F1B2     		uxtb	r1, r6
 465 00b0 FFF7FEFF 		bl	I2C_SendData
 466              	.LVL32:
1273:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 467              		.loc 1 1273 0
 468 00b4 4FF4B840 		mov	r0, #23552
 469 00b8 C4F20000 		movt	r0, 16384
 470 00bc 0121     		movs	r1, #1
 471 00be FFF7FEFF 		bl	I2C_GenerateSTART
 472              	.LVL33:
1276:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 473              		.loc 1 1276 0
 474 00c2 4FF44052 		mov	r2, #12288
 475 00c6 2260     		str	r2, [r4, #0]
 476 00c8 04E0     		b	.L17
 477              	.L18:
1279:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 478              		.loc 1 1279 0
 479 00ca 2168     		ldr	r1, [r4, #0]
 480 00cc 4A1E     		subs	r2, r1, #1
 481 00ce 2260     		str	r2, [r4, #0]
 482 00d0 0029     		cmp	r1, #0
 483 00d2 6CD0     		beq	.L29
 484              	.L17:
1277:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
 485              		.loc 1 1277 0
 486 00d4 4FF4B840 		mov	r0, #23552
 487 00d8 0121     		movs	r1, #1
 488 00da C4F20000 		movt	r0, 16384
 489 00de C1F20001 		movt	r1, 4096
 490 00e2 FFF7FEFF 		bl	I2C_GetFlagStatus
 491              	.LVL34:
 492 00e6 0028     		cmp	r0, #0
 493 00e8 EFD0     		beq	.L18
1283:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Receiver);
 494              		.loc 1 1283 0
 495 00ea 4FF4B840 		mov	r0, #23552
 496 00ee C4F20000 		movt	r0, 16384
 497 00f2 8221     		movs	r1, #130
 498 00f4 0122     		movs	r2, #1
1286:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 499              		.loc 1 1286 0
 500 00f6 4FF44055 		mov	r5, #12288
1283:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Receiver);
 501              		.loc 1 1283 0
 502 00fa FFF7FEFF 		bl	I2C_Send7bitAddress
 503              	.LVL35:
1286:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 504              		.loc 1 1286 0
 505 00fe 2560     		str	r5, [r4, #0]
 506 0100 04E0     		b	.L19
 507              	.L20:
1289:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 508              		.loc 1 1289 0
 509 0102 2368     		ldr	r3, [r4, #0]
 510 0104 581E     		subs	r0, r3, #1
 511 0106 2060     		str	r0, [r4, #0]
 512 0108 002B     		cmp	r3, #0
 513 010a 50D0     		beq	.L29
 514              	.L19:
1287:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
 515              		.loc 1 1287 0
 516 010c 4FF4B845 		mov	r5, #23552
 517 0110 C4F20005 		movt	r5, 16384
 518 0114 0221     		movs	r1, #2
 519 0116 2846     		mov	r0, r5
 520 0118 C1F20001 		movt	r1, 4096
 521 011c FFF7FEFF 		bl	I2C_GetFlagStatus
 522              	.LVL36:
 523 0120 0028     		cmp	r0, #0
 524 0122 EED0     		beq	.L20
1293:stm32f429i_discovery_ioe.c ****   I2C_AcknowledgeConfig(IOE_I2C, DISABLE);       
 525              		.loc 1 1293 0
 526 0124 0021     		movs	r1, #0
 527 0126 2846     		mov	r0, r5
 528 0128 FFF7FEFF 		bl	I2C_AcknowledgeConfig
 529              	.LVL37:
1294:stm32f429i_discovery_ioe.c ****   I2C_NACKPositionConfig(IOE_I2C, I2C_NACKPosition_Next);
 530              		.loc 1 1294 0
 531 012c 2846     		mov	r0, r5
 532 012e 4FF40061 		mov	r1, #2048
 533 0132 FFF7FEFF 		bl	I2C_NACKPositionConfig
 534              	.LVL38:
1297:stm32f429i_discovery_ioe.c ****   IOE_I2C->SR2;
 535              		.loc 1 1297 0
 536 0136 2B8B     		ldrh	r3, [r5, #24]
1300:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 537              		.loc 1 1300 0
 538 0138 4FF44053 		mov	r3, #12288
 539 013c 2360     		str	r3, [r4, #0]
 540 013e 03E0     		b	.L21
 541              	.L22:
1303:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 542              		.loc 1 1303 0
 543 0140 2168     		ldr	r1, [r4, #0]
 544 0142 4A1E     		subs	r2, r1, #1
 545 0144 2260     		str	r2, [r4, #0]
 546 0146 91B3     		cbz	r1, .L29
 547              	.L21:
1301:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_BTF))
 548              		.loc 1 1301 0
 549 0148 4FF4B840 		mov	r0, #23552
 550 014c 0421     		movs	r1, #4
 551 014e C4F20000 		movt	r0, 16384
 552 0152 C1F20001 		movt	r1, 4096
 553 0156 FFF7FEFF 		bl	I2C_GetFlagStatus
 554              	.LVL39:
 555 015a 0028     		cmp	r0, #0
 556 015c F0D0     		beq	.L22
1307:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTOP(IOE_I2C, ENABLE);
 557              		.loc 1 1307 0
 558 015e 4FF4B840 		mov	r0, #23552
 559 0162 0121     		movs	r1, #1
 560 0164 C4F20000 		movt	r0, 16384
 561 0168 FFF7FEFF 		bl	I2C_GenerateSTOP
 562              	.LVL40:
1310:stm32f429i_discovery_ioe.c ****   IOE_BufferRX[1] = I2C_ReceiveData(IOE_I2C);
 563              		.loc 1 1310 0
 564 016c 4FF4B840 		mov	r0, #23552
 565 0170 C4F20000 		movt	r0, 16384
 566 0174 FFF7FEFF 		bl	I2C_ReceiveData
 567              	.LVL41:
 568 0178 0546     		mov	r5, r0
 569              	.LVL42:
1313:stm32f429i_discovery_ioe.c ****   IOE_BufferRX[0] = I2C_ReceiveData(IOE_I2C);
 570              		.loc 1 1313 0
 571 017a 4FF4B840 		mov	r0, #23552
 572              	.LVL43:
 573 017e C4F20000 		movt	r0, 16384
 574 0182 FFF7FEFF 		bl	I2C_ReceiveData
 575              	.LVL44:
 576 0186 0446     		mov	r4, r0
 577              	.LVL45:
1316:stm32f429i_discovery_ioe.c ****   I2C_AcknowledgeConfig(IOE_I2C, ENABLE);
 578              		.loc 1 1316 0
 579 0188 4FF4B840 		mov	r0, #23552
 580              	.LVL46:
 581 018c 0121     		movs	r1, #1
 582 018e C4F20000 		movt	r0, 16384
 583 0192 FFF7FEFF 		bl	I2C_AcknowledgeConfig
 584              	.LVL47:
1317:stm32f429i_discovery_ioe.c ****   I2C_NACKPositionConfig(IOE_I2C, I2C_NACKPosition_Current);
 585              		.loc 1 1317 0
 586 0196 4FF4B840 		mov	r0, #23552
 587 019a C4F20000 		movt	r0, 16384
 588 019e 4FF2FF71 		movw	r1, #63487
 589 01a2 FFF7FEFF 		bl	I2C_NACKPositionConfig
 590              	.LVL48:
1320:stm32f429i_discovery_ioe.c ****   return ((uint16_t) IOE_BufferRX[0] | ((uint16_t)IOE_BufferRX[1]<< 8));
 591              		.loc 1 1320 0
 592 01a6 44EA0520 		orr	r0, r4, r5, lsl #8
 593 01aa 80B2     		uxth	r0, r0
 594              	.LBE9:
 595              	.LBE8:
1321:stm32f429i_discovery_ioe.c **** }
 596              		.loc 1 1321 0
 597 01ac 70BD     		pop	{r4, r5, r6, pc}
 598              	.LVL49:
 599              	.L29:
 600              	.LBB11:
 601              	.LBB10:
1303:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 602              		.loc 1 1303 0
 603 01ae FFF7FEFF 		bl	IOE_TimeoutUserCallback
 604              	.LVL50:
 605 01b2 70BD     		pop	{r4, r5, r6, pc}
 606              	.L31:
 607              		.align	2
 608              	.L30:
 609 01b4 00000000 		.word	.LANCHOR0
 610              	.LBE10:
 611              	.LBE11:
 612              		.cfi_endproc
 613              	.LFE136:
 615 01b8 AFF30080 		.section	.text.I2C_ReadDeviceRegister,"ax",%progbits
 615      AFF30080 
 616              		.align	2
 617              		.p2align 4,,15
 618              		.global	I2C_ReadDeviceRegister
 619              		.thumb
 620              		.thumb_func
 622              	I2C_ReadDeviceRegister:
 623              	.LFB135:
1141:stm32f429i_discovery_ioe.c **** {
 624              		.loc 1 1141 0
 625              		.cfi_startproc
 626              		@ args = 0, pretend = 0, frame = 0
 627              		@ frame_needed = 0, uses_anonymous_args = 0
 628              	.LVL51:
 629 0000 70B5     		push	{r4, r5, r6, lr}
 630              	.LCFI7:
 631              		.cfi_def_cfa_offset 16
 632              		.cfi_offset 4, -16
 633              		.cfi_offset 5, -12
 634              		.cfi_offset 6, -8
 635              		.cfi_offset 14, -4
1141:stm32f429i_discovery_ioe.c **** {
 636              		.loc 1 1141 0
 637 0002 0646     		mov	r6, r0
1145:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 638              		.loc 1 1145 0
 639 0004 4FF4B840 		mov	r0, #23552
 640              	.LVL52:
 641 0008 C4F20000 		movt	r0, 16384
 642 000c 0121     		movs	r1, #1
1148:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 643              		.loc 1 1148 0
 644 000e 6D4C     		ldr	r4, .L65
1145:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 645              		.loc 1 1145 0
 646 0010 FFF7FEFF 		bl	I2C_GenerateSTART
 647              	.LVL53:
1148:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 648              		.loc 1 1148 0
 649 0014 4FF44053 		mov	r3, #12288
 650 0018 2360     		str	r3, [r4, #0]
 651              	.L33:
1149:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
 652              		.loc 1 1149 0 discriminator 1
 653 001a 4FF4B840 		mov	r0, #23552
 654 001e 0121     		movs	r1, #1
 655 0020 C4F20000 		movt	r0, 16384
 656 0024 C1F20001 		movt	r1, 4096
 657 0028 FFF7FEFF 		bl	I2C_GetFlagStatus
 658              	.LVL54:
 659 002c 40B9     		cbnz	r0, .L61
1151:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 660              		.loc 1 1151 0
 661 002e 2168     		ldr	r1, [r4, #0]
 662 0030 4A1E     		subs	r2, r1, #1
 663 0032 2260     		str	r2, [r4, #0]
 664 0034 0029     		cmp	r1, #0
 665 0036 F0D1     		bne	.L33
 666              	.L60:
1228:stm32f429i_discovery_ioe.c **** }
 667              		.loc 1 1228 0
 668 0038 BDE87040 		pop	{r4, r5, r6, lr}
 669              	.LBB14:
 670              	.LBB15:
1213:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 671              		.loc 1 1213 0
 672 003c FFF7FEBF 		b	IOE_TimeoutUserCallback
 673              	.LVL55:
 674              	.L61:
1154:stm32f429i_discovery_ioe.c ****   I2C_AcknowledgeConfig(IOE_I2C, DISABLE);
 675              		.loc 1 1154 0
 676 0040 4FF4B840 		mov	r0, #23552
 677 0044 C4F20000 		movt	r0, 16384
 678 0048 0021     		movs	r1, #0
 679 004a FFF7FEFF 		bl	I2C_AcknowledgeConfig
 680              	.LVL56:
1157:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Transmitter);
 681              		.loc 1 1157 0
 682 004e 4FF4B840 		mov	r0, #23552
 683 0052 C4F20000 		movt	r0, 16384
 684 0056 8221     		movs	r1, #130
 685 0058 0022     		movs	r2, #0
 686 005a FFF7FEFF 		bl	I2C_Send7bitAddress
 687              	.LVL57:
1160:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;  
 688              		.loc 1 1160 0
 689 005e 4FF44050 		mov	r0, #12288
 690 0062 2060     		str	r0, [r4, #0]
 691              	.L35:
1161:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
 692              		.loc 1 1161 0
 693 0064 4FF4B845 		mov	r5, #23552
 694 0068 C4F20005 		movt	r5, 16384
 695 006c 0221     		movs	r1, #2
 696 006e 2846     		mov	r0, r5
 697 0070 C1F20001 		movt	r1, 4096
 698 0074 FFF7FEFF 		bl	I2C_GetFlagStatus
 699              	.LVL58:
 700 0078 28B9     		cbnz	r0, .L62
1163:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 701              		.loc 1 1163 0
 702 007a 2368     		ldr	r3, [r4, #0]
 703 007c 581E     		subs	r0, r3, #1
 704 007e 2060     		str	r0, [r4, #0]
 705 0080 002B     		cmp	r3, #0
 706 0082 EFD1     		bne	.L35
 707 0084 D8E7     		b	.L60
 708              	.L62:
1170:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 709              		.loc 1 1170 0
 710 0086 4FF44051 		mov	r1, #12288
1167:stm32f429i_discovery_ioe.c ****   IOE_I2C->SR2;
 711              		.loc 1 1167 0
 712 008a 2B8B     		ldrh	r3, [r5, #24]
1170:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 713              		.loc 1 1170 0
 714 008c 2160     		str	r1, [r4, #0]
 715              	.L37:
1171:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE))
 716              		.loc 1 1171 0
 717 008e 4FF4B840 		mov	r0, #23552
 718 0092 8021     		movs	r1, #128
 719 0094 C4F20000 		movt	r0, 16384
 720 0098 C1F20001 		movt	r1, 4096
 721 009c FFF7FEFF 		bl	I2C_GetFlagStatus
 722              	.LVL59:
 723 00a0 28B9     		cbnz	r0, .L63
1173:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 724              		.loc 1 1173 0
 725 00a2 2168     		ldr	r1, [r4, #0]
 726 00a4 4A1E     		subs	r2, r1, #1
 727 00a6 2260     		str	r2, [r4, #0]
 728 00a8 0029     		cmp	r1, #0
 729 00aa F0D1     		bne	.L37
 730 00ac C4E7     		b	.L60
 731              	.L63:
1177:stm32f429i_discovery_ioe.c ****   I2C_SendData(IOE_I2C, RegisterAddr);
 732              		.loc 1 1177 0
 733 00ae 4FF4B840 		mov	r0, #23552
 734 00b2 C4F20000 		movt	r0, 16384
 735 00b6 3146     		mov	r1, r6
 736 00b8 FFF7FEFF 		bl	I2C_SendData
 737              	.LVL60:
1180:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 738              		.loc 1 1180 0
 739 00bc 4FF44052 		mov	r2, #12288
 740 00c0 2260     		str	r2, [r4, #0]
 741 00c2 04E0     		b	.L39
 742              	.L40:
1183:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 743              		.loc 1 1183 0
 744 00c4 2368     		ldr	r3, [r4, #0]
 745 00c6 581E     		subs	r0, r3, #1
 746 00c8 2060     		str	r0, [r4, #0]
 747 00ca 002B     		cmp	r3, #0
 748 00cc B4D0     		beq	.L60
 749              	.L39:
1181:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE)) || (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_BTF))
 750              		.loc 1 1181 0
 751 00ce 4FF4B840 		mov	r0, #23552
 752 00d2 8021     		movs	r1, #128
 753 00d4 C1F20001 		movt	r1, 4096
 754 00d8 C4F20000 		movt	r0, 16384
 755 00dc FFF7FEFF 		bl	I2C_GetFlagStatus
 756              	.LVL61:
 757 00e0 0028     		cmp	r0, #0
 758 00e2 EFD0     		beq	.L40
 759 00e4 4FF4B840 		mov	r0, #23552
 760 00e8 0421     		movs	r1, #4
 761 00ea C4F20000 		movt	r0, 16384
 762 00ee C1F20001 		movt	r1, 4096
 763 00f2 FFF7FEFF 		bl	I2C_GetFlagStatus
 764              	.LVL62:
 765 00f6 0028     		cmp	r0, #0
 766 00f8 E4D0     		beq	.L40
1187:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 767              		.loc 1 1187 0
 768 00fa 4FF4B840 		mov	r0, #23552
 769 00fe C4F20000 		movt	r0, 16384
 770 0102 0121     		movs	r1, #1
 771 0104 FFF7FEFF 		bl	I2C_GenerateSTART
 772              	.LVL63:
1190:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 773              		.loc 1 1190 0
 774 0108 4FF44053 		mov	r3, #12288
 775 010c 2360     		str	r3, [r4, #0]
 776              	.L41:
1191:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
 777              		.loc 1 1191 0
 778 010e 4FF4B840 		mov	r0, #23552
 779 0112 0121     		movs	r1, #1
 780 0114 C4F20000 		movt	r0, 16384
 781 0118 C1F20001 		movt	r1, 4096
 782 011c FFF7FEFF 		bl	I2C_GetFlagStatus
 783              	.LVL64:
 784 0120 28B9     		cbnz	r0, .L64
1193:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 785              		.loc 1 1193 0
 786 0122 2168     		ldr	r1, [r4, #0]
 787 0124 4A1E     		subs	r2, r1, #1
 788 0126 2260     		str	r2, [r4, #0]
 789 0128 0029     		cmp	r1, #0
 790 012a F0D1     		bne	.L41
 791 012c 84E7     		b	.L60
 792              	.L64:
1197:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Receiver);
 793              		.loc 1 1197 0
 794 012e 4FF4B840 		mov	r0, #23552
 795 0132 C4F20000 		movt	r0, 16384
 796 0136 8221     		movs	r1, #130
 797 0138 0122     		movs	r2, #1
1200:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 798              		.loc 1 1200 0
 799 013a 4FF44055 		mov	r5, #12288
1197:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Receiver);
 800              		.loc 1 1197 0
 801 013e FFF7FEFF 		bl	I2C_Send7bitAddress
 802              	.LVL65:
1200:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 803              		.loc 1 1200 0
 804 0142 2560     		str	r5, [r4, #0]
 805 0144 05E0     		b	.L43
 806              	.L44:
1203:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 807              		.loc 1 1203 0
 808 0146 2368     		ldr	r3, [r4, #0]
 809 0148 581E     		subs	r0, r3, #1
 810 014a 2060     		str	r0, [r4, #0]
 811 014c 002B     		cmp	r3, #0
 812 014e 3FF473AF 		beq	.L60
 813              	.L43:
1201:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
 814              		.loc 1 1201 0
 815 0152 4FF4B845 		mov	r5, #23552
 816 0156 C4F20005 		movt	r5, 16384
 817 015a 0221     		movs	r1, #2
 818 015c 2846     		mov	r0, r5
 819 015e C1F20001 		movt	r1, 4096
 820 0162 FFF7FEFF 		bl	I2C_GetFlagStatus
 821              	.LVL66:
 822 0166 0028     		cmp	r0, #0
 823 0168 EDD0     		beq	.L44
1210:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 824              		.loc 1 1210 0
 825 016a 4FF44050 		mov	r0, #12288
1207:stm32f429i_discovery_ioe.c ****   IOE_I2C->SR2;
 826              		.loc 1 1207 0
 827 016e 2B8B     		ldrh	r3, [r5, #24]
1210:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 828              		.loc 1 1210 0
 829 0170 2060     		str	r0, [r4, #0]
 830 0172 05E0     		b	.L45
 831              	.L46:
1213:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 832              		.loc 1 1213 0
 833 0174 2168     		ldr	r1, [r4, #0]
 834 0176 4A1E     		subs	r2, r1, #1
 835 0178 2260     		str	r2, [r4, #0]
 836 017a 0029     		cmp	r1, #0
 837 017c 3FF45CAF 		beq	.L60
 838              	.L45:
1211:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_RXNE))
 839              		.loc 1 1211 0
 840 0180 4FF4B840 		mov	r0, #23552
 841 0184 4021     		movs	r1, #64
 842 0186 C4F20000 		movt	r0, 16384
 843 018a C1F20001 		movt	r1, 4096
 844 018e FFF7FEFF 		bl	I2C_GetFlagStatus
 845              	.LVL67:
 846 0192 0028     		cmp	r0, #0
 847 0194 EED0     		beq	.L46
1217:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTOP(IOE_I2C, ENABLE);
 848              		.loc 1 1217 0
 849 0196 4FF4B840 		mov	r0, #23552
 850 019a 0121     		movs	r1, #1
 851 019c C4F20000 		movt	r0, 16384
 852 01a0 FFF7FEFF 		bl	I2C_GenerateSTOP
 853              	.LVL68:
1220:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReceiveData(IOE_I2C);
 854              		.loc 1 1220 0
 855 01a4 4FF4B840 		mov	r0, #23552
 856 01a8 C4F20000 		movt	r0, 16384
 857 01ac FFF7FEFF 		bl	I2C_ReceiveData
 858              	.LVL69:
 859 01b0 0446     		mov	r4, r0
 860              	.LVL70:
1223:stm32f429i_discovery_ioe.c ****   I2C_AcknowledgeConfig(IOE_I2C, ENABLE);
 861              		.loc 1 1223 0
 862 01b2 4FF4B840 		mov	r0, #23552
 863              	.LVL71:
 864 01b6 C4F20000 		movt	r0, 16384
 865 01ba 0121     		movs	r1, #1
 866 01bc FFF7FEFF 		bl	I2C_AcknowledgeConfig
 867              	.LVL72:
 868              	.LBE15:
 869              	.LBE14:
1228:stm32f429i_discovery_ioe.c **** }
 870              		.loc 1 1228 0
 871 01c0 2046     		mov	r0, r4
 872 01c2 70BD     		pop	{r4, r5, r6, pc}
 873              	.L66:
 874              		.align	2
 875              	.L65:
 876 01c4 00000000 		.word	.LANCHOR0
 877              		.cfi_endproc
 878              	.LFE135:
 880              		.section	.text.IOE_ReadID,"ax",%progbits
 881              		.align	2
 882              		.p2align 4,,15
 883              		.global	IOE_ReadID
 884              		.thumb
 885              		.thumb_func
 887              	IOE_ReadID:
 888              	.LFB119:
 317:stm32f429i_discovery_ioe.c **** {
 889              		.loc 1 317 0
 890              		.cfi_startproc
 891              		@ args = 0, pretend = 0, frame = 0
 892              		@ frame_needed = 0, uses_anonymous_args = 0
 893              	.LVL73:
 894 0000 10B5     		push	{r4, lr}
 895              	.LCFI8:
 896              		.cfi_def_cfa_offset 8
 897              		.cfi_offset 4, -8
 898              		.cfi_offset 14, -4
 321:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReadDeviceRegister(0);
 899              		.loc 1 321 0
 900 0002 0020     		movs	r0, #0
 901 0004 FFF7FEFF 		bl	I2C_ReadDeviceRegister
 902              	.LVL74:
 322:stm32f429i_discovery_ioe.c ****   tmp = (uint32_t)(tmp << 8);
 903              		.loc 1 322 0
 904 0008 0402     		lsls	r4, r0, #8
 323:stm32f429i_discovery_ioe.c ****   tmp |= (uint32_t)I2C_ReadDeviceRegister(1);
 905              		.loc 1 323 0
 906 000a 0120     		movs	r0, #1
 907              	.LVL75:
 908 000c FFF7FEFF 		bl	I2C_ReadDeviceRegister
 909              	.LVL76:
 322:stm32f429i_discovery_ioe.c ****   tmp = (uint32_t)(tmp << 8);
 910              		.loc 1 322 0
 911 0010 A4B2     		uxth	r4, r4
 912              	.LVL77:
 323:stm32f429i_discovery_ioe.c ****   tmp |= (uint32_t)I2C_ReadDeviceRegister(1);
 913              		.loc 1 323 0
 914 0012 2043     		orrs	r0, r0, r4
 915              	.LVL78:
 327:stm32f429i_discovery_ioe.c **** }
 916              		.loc 1 327 0
 917 0014 80B2     		uxth	r0, r0
 918 0016 10BD     		pop	{r4, pc}
 919              		.cfi_endproc
 920              	.LFE119:
 922 0018 AFF30080 		.section	.text.IOE_GetGITStatus,"ax",%progbits
 922      AFF30080 
 923              		.align	2
 924              		.p2align 4,,15
 925              		.global	IOE_GetGITStatus
 926              		.thumb
 927              		.thumb_func
 929              	IOE_GetGITStatus:
 930              	.LFB115:
 226:stm32f429i_discovery_ioe.c **** {
 931              		.loc 1 226 0
 932              		.cfi_startproc
 933              		@ args = 0, pretend = 0, frame = 8
 934              		@ frame_needed = 0, uses_anonymous_args = 0
 935              	.LVL79:
 936 0000 10B5     		push	{r4, lr}
 937              	.LCFI9:
 938              		.cfi_def_cfa_offset 8
 939              		.cfi_offset 4, -8
 940              		.cfi_offset 14, -4
 941 0002 82B0     		sub	sp, sp, #8
 942              	.LCFI10:
 943              		.cfi_def_cfa_offset 16
 227:stm32f429i_discovery_ioe.c ****   __IO uint8_t tmp = 0;
 944              		.loc 1 227 0
 945 0004 0023     		movs	r3, #0
 226:stm32f429i_discovery_ioe.c **** {
 946              		.loc 1 226 0
 947 0006 0446     		mov	r4, r0
 230:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReadDeviceRegister(IOE_REG_INT_STA);
 948              		.loc 1 230 0
 949 0008 0B20     		movs	r0, #11
 950              	.LVL80:
 227:stm32f429i_discovery_ioe.c ****   __IO uint8_t tmp = 0;
 951              		.loc 1 227 0
 952 000a 8DF80730 		strb	r3, [sp, #7]
 953              	.LVL81:
 230:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReadDeviceRegister(IOE_REG_INT_STA);
 954              		.loc 1 230 0
 955 000e FFF7FEFF 		bl	I2C_ReadDeviceRegister
 956              	.LVL82:
 957 0012 8DF80700 		strb	r0, [sp, #7]
 232:stm32f429i_discovery_ioe.c ****   if ((tmp & (uint8_t)Global_IT) != 0)
 958              		.loc 1 232 0
 959 0016 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 960              	.LVL83:
 961 001a 0442     		tst	r4, r0
 240:stm32f429i_discovery_ioe.c **** }
 962              		.loc 1 240 0
 963 001c 0CBF     		ite	eq
 964 001e 0020     		moveq	r0, #0
 965 0020 0120     		movne	r0, #1
 966              	.LVL84:
 967 0022 02B0     		add	sp, sp, #8
 968 0024 10BD     		pop	{r4, pc}
 969              		.cfi_endproc
 970              	.LFE115:
 972 0026 00BFAFF3 		.section	.text.I2C_WriteDeviceRegister,"ax",%progbits
 972      0080AFF3 
 972      0080
 973              		.align	2
 974              		.p2align 4,,15
 975              		.global	I2C_WriteDeviceRegister
 976              		.thumb
 977              		.thumb_func
 979              	I2C_WriteDeviceRegister:
 980              	.LFB134:
1055:stm32f429i_discovery_ioe.c **** {
 981              		.loc 1 1055 0
 982              		.cfi_startproc
 983              		@ args = 0, pretend = 0, frame = 0
 984              		@ frame_needed = 0, uses_anonymous_args = 0
 985              	.LVL85:
 986 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 987              	.LCFI11:
 988              		.cfi_def_cfa_offset 24
 989              		.cfi_offset 3, -24
 990              		.cfi_offset 4, -20
 991              		.cfi_offset 5, -16
 992              		.cfi_offset 6, -12
 993              		.cfi_offset 7, -8
 994              		.cfi_offset 14, -4
1055:stm32f429i_discovery_ioe.c **** {
 995              		.loc 1 1055 0
 996 0002 0646     		mov	r6, r0
1059:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 997              		.loc 1 1059 0
 998 0004 4FF4B840 		mov	r0, #23552
 999              	.LVL86:
1055:stm32f429i_discovery_ioe.c **** {
 1000              		.loc 1 1055 0
 1001 0008 0F46     		mov	r7, r1
1059:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 1002              		.loc 1 1059 0
 1003 000a C4F20000 		movt	r0, 16384
 1004 000e 0121     		movs	r1, #1
 1005              	.LVL87:
1062:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 1006              		.loc 1 1062 0
 1007 0010 4B4C     		ldr	r4, .L92
1059:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 1008              		.loc 1 1059 0
 1009 0012 FFF7FEFF 		bl	I2C_GenerateSTART
 1010              	.LVL88:
1062:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 1011              		.loc 1 1062 0
 1012 0016 4FF44053 		mov	r3, #12288
 1013 001a 2360     		str	r3, [r4, #0]
1063:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
 1014              		.loc 1 1063 0
 1015 001c 05E0     		b	.L70
 1016              	.L71:
1065:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 1017              		.loc 1 1065 0
 1018 001e 2068     		ldr	r0, [r4, #0]
 1019 0020 411E     		subs	r1, r0, #1
 1020 0022 2160     		str	r1, [r4, #0]
 1021 0024 0028     		cmp	r0, #0
 1022 0026 00F08680 		beq	.L91
 1023              	.L70:
1063:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_SB))
 1024              		.loc 1 1063 0 discriminator 1
 1025 002a 4FF4B840 		mov	r0, #23552
 1026 002e 0121     		movs	r1, #1
 1027 0030 C4F20000 		movt	r0, 16384
 1028 0034 C1F20001 		movt	r1, 4096
 1029 0038 FFF7FEFF 		bl	I2C_GetFlagStatus
 1030              	.LVL89:
 1031 003c 0028     		cmp	r0, #0
 1032 003e EED0     		beq	.L71
 1033              	.LVL90:
 1034              	.LBB18:
 1035              	.LBB19:
1069:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Transmitter);
 1036              		.loc 1 1069 0
 1037 0040 4FF4B840 		mov	r0, #23552
 1038 0044 C4F20000 		movt	r0, 16384
 1039 0048 8221     		movs	r1, #130
 1040 004a 0022     		movs	r2, #0
 1041 004c FFF7FEFF 		bl	I2C_Send7bitAddress
 1042              	.LVL91:
1072:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;  
 1043              		.loc 1 1072 0
 1044 0050 4FF44050 		mov	r0, #12288
 1045 0054 2060     		str	r0, [r4, #0]
 1046 0056 04E0     		b	.L72
 1047              	.L73:
1075:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 1048              		.loc 1 1075 0
 1049 0058 2368     		ldr	r3, [r4, #0]
 1050 005a 5A1E     		subs	r2, r3, #1
 1051 005c 2260     		str	r2, [r4, #0]
 1052 005e 002B     		cmp	r3, #0
 1053 0060 69D0     		beq	.L91
 1054              	.L72:
1073:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_ADDR))
 1055              		.loc 1 1073 0
 1056 0062 4FF4B845 		mov	r5, #23552
 1057 0066 C4F20005 		movt	r5, 16384
 1058 006a 0221     		movs	r1, #2
 1059 006c 2846     		mov	r0, r5
 1060 006e C1F20001 		movt	r1, 4096
 1061 0072 FFF7FEFF 		bl	I2C_GetFlagStatus
 1062              	.LVL92:
 1063 0076 0028     		cmp	r0, #0
 1064 0078 EED0     		beq	.L73
1082:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 1065              		.loc 1 1082 0
 1066 007a 4FF44051 		mov	r1, #12288
1079:stm32f429i_discovery_ioe.c ****   IOE_I2C->SR2;
 1067              		.loc 1 1079 0
 1068 007e 2B8B     		ldrh	r3, [r5, #24]
1082:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 1069              		.loc 1 1082 0
 1070 0080 2160     		str	r1, [r4, #0]
 1071 0082 04E0     		b	.L74
 1072              	.L75:
1085:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 1073              		.loc 1 1085 0
 1074 0084 2068     		ldr	r0, [r4, #0]
 1075 0086 411E     		subs	r1, r0, #1
 1076 0088 2160     		str	r1, [r4, #0]
 1077 008a 0028     		cmp	r0, #0
 1078 008c 53D0     		beq	.L91
 1079              	.L74:
1083:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE))
 1080              		.loc 1 1083 0
 1081 008e 4FF4B840 		mov	r0, #23552
 1082 0092 8021     		movs	r1, #128
 1083 0094 C4F20000 		movt	r0, 16384
 1084 0098 C1F20001 		movt	r1, 4096
 1085 009c FFF7FEFF 		bl	I2C_GetFlagStatus
 1086              	.LVL93:
 1087 00a0 0028     		cmp	r0, #0
 1088 00a2 EFD0     		beq	.L75
1089:stm32f429i_discovery_ioe.c ****   I2C_SendData(IOE_I2C, RegisterAddr);
 1089              		.loc 1 1089 0
 1090 00a4 4FF4B840 		mov	r0, #23552
 1091 00a8 C4F20000 		movt	r0, 16384
 1092 00ac 3146     		mov	r1, r6
 1093 00ae FFF7FEFF 		bl	I2C_SendData
 1094              	.LVL94:
1092:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 1095              		.loc 1 1092 0
 1096 00b2 4FF44052 		mov	r2, #12288
 1097 00b6 2260     		str	r2, [r4, #0]
 1098 00b8 04E0     		b	.L76
 1099              	.L77:
1095:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 1100              		.loc 1 1095 0
 1101 00ba 2368     		ldr	r3, [r4, #0]
 1102 00bc 5A1E     		subs	r2, r3, #1
 1103 00be 2260     		str	r2, [r4, #0]
 1104 00c0 002B     		cmp	r3, #0
 1105 00c2 38D0     		beq	.L91
 1106              	.L76:
1093:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE))
 1107              		.loc 1 1093 0
 1108 00c4 4FF4B840 		mov	r0, #23552
 1109 00c8 8021     		movs	r1, #128
 1110 00ca C4F20000 		movt	r0, 16384
 1111 00ce C1F20001 		movt	r1, 4096
 1112 00d2 FFF7FEFF 		bl	I2C_GetFlagStatus
 1113              	.LVL95:
 1114 00d6 0028     		cmp	r0, #0
 1115 00d8 EFD0     		beq	.L77
1099:stm32f429i_discovery_ioe.c ****   I2C_SendData(IOE_I2C, RegisterValue);
 1116              		.loc 1 1099 0
 1117 00da 4FF4B840 		mov	r0, #23552
 1118 00de C4F20000 		movt	r0, 16384
 1119 00e2 3946     		mov	r1, r7
 1120 00e4 FFF7FEFF 		bl	I2C_SendData
 1121              	.LVL96:
1102:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 1122              		.loc 1 1102 0
 1123 00e8 4FF44053 		mov	r3, #12288
 1124 00ec 2360     		str	r3, [r4, #0]
 1125 00ee 03E0     		b	.L78
 1126              	.L79:
1105:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 1127              		.loc 1 1105 0
 1128 00f0 2068     		ldr	r0, [r4, #0]
 1129 00f2 411E     		subs	r1, r0, #1
 1130 00f4 2160     		str	r1, [r4, #0]
 1131 00f6 F0B1     		cbz	r0, .L91
 1132              	.L78:
1103:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_TXE)) || (!I2C_GetFlagStatus(IOE_I2C, I2C_FLAG_BTF))
 1133              		.loc 1 1103 0
 1134 00f8 4FF4B840 		mov	r0, #23552
 1135 00fc 8021     		movs	r1, #128
 1136 00fe C1F20001 		movt	r1, 4096
 1137 0102 C4F20000 		movt	r0, 16384
 1138 0106 FFF7FEFF 		bl	I2C_GetFlagStatus
 1139              	.LVL97:
 1140 010a 0028     		cmp	r0, #0
 1141 010c F0D0     		beq	.L79
 1142 010e 4FF4B840 		mov	r0, #23552
 1143 0112 0421     		movs	r1, #4
 1144 0114 C4F20000 		movt	r0, 16384
 1145 0118 C1F20001 		movt	r1, 4096
 1146 011c FFF7FEFF 		bl	I2C_GetFlagStatus
 1147              	.LVL98:
 1148 0120 0028     		cmp	r0, #0
 1149 0122 E5D0     		beq	.L79
1109:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTOP(IOE_I2C, ENABLE);
 1150              		.loc 1 1109 0
 1151 0124 4FF4B840 		mov	r0, #23552
 1152 0128 C4F20000 		movt	r0, 16384
 1153 012c 0121     		movs	r1, #1
 1154 012e FFF7FEFF 		bl	I2C_GenerateSTOP
 1155              	.LVL99:
 1156              	.LBE19:
 1157              	.LBE18:
1133:stm32f429i_discovery_ioe.c **** }
 1158              		.loc 1 1133 0
 1159 0132 0020     		movs	r0, #0
 1160 0134 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1161              	.LVL100:
 1162              	.L91:
 1163 0136 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 1164              	.LBB21:
 1165              	.LBB20:
1105:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 1166              		.loc 1 1105 0
 1167 013a FFF7FEBF 		b	IOE_TimeoutUserCallback
 1168              	.LVL101:
 1169              	.L93:
 1170 013e 00BF     		.align	2
 1171              	.L92:
 1172 0140 00000000 		.word	.LANCHOR0
 1173              	.LBE20:
 1174              	.LBE21:
 1175              		.cfi_endproc
 1176              	.LFE134:
 1178 0144 AFF30080 		.section	.text.IOE_IOAFConfig,"ax",%progbits
 1178      AFF30080 
 1178      AFF30080 
 1179              		.align	2
 1180              		.p2align 4,,15
 1181              		.global	IOE_IOAFConfig
 1182              		.thumb
 1183              		.thumb_func
 1185              	IOE_IOAFConfig:
 1186              	.LFB124:
 493:stm32f429i_discovery_ioe.c **** {
 1187              		.loc 1 493 0
 1188              		.cfi_startproc
 1189              		@ args = 0, pretend = 0, frame = 0
 1190              		@ frame_needed = 0, uses_anonymous_args = 0
 1191              	.LVL102:
 1192 0000 38B5     		push	{r3, r4, r5, lr}
 1193              	.LCFI12:
 1194              		.cfi_def_cfa_offset 16
 1195              		.cfi_offset 3, -16
 1196              		.cfi_offset 4, -12
 1197              		.cfi_offset 5, -8
 1198              		.cfi_offset 14, -4
 493:stm32f429i_discovery_ioe.c **** {
 1199              		.loc 1 493 0
 1200 0002 0446     		mov	r4, r0
 1201 0004 0D46     		mov	r5, r1
 497:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReadDeviceRegister(IOE_REG_GPIO_AF);
 1202              		.loc 1 497 0
 1203 0006 1720     		movs	r0, #23
 1204              	.LVL103:
 1205 0008 FFF7FEFF 		bl	I2C_ReadDeviceRegister
 1206              	.LVL104:
 499:stm32f429i_discovery_ioe.c ****   if (NewState != DISABLE)
 1207              		.loc 1 499 0
 1208 000c 3DB9     		cbnz	r5, .L97
 507:stm32f429i_discovery_ioe.c ****     tmp &= ~(uint8_t)IO_Pin;   
 1209              		.loc 1 507 0
 1210 000e 20EA0404 		bic	r4, r0, r4
 1211 0012 E1B2     		uxtb	r1, r4
 1212              	.LVL105:
 1213              	.L96:
 511:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_GPIO_AF, tmp);  
 1214              		.loc 1 511 0
 1215 0014 1720     		movs	r0, #23
 1216 0016 FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1217              	.LVL106:
 515:stm32f429i_discovery_ioe.c **** }
 1218              		.loc 1 515 0
 1219 001a 0020     		movs	r0, #0
 1220 001c 38BD     		pop	{r3, r4, r5, pc}
 1221              	.LVL107:
 1222              	.L97:
 502:stm32f429i_discovery_ioe.c ****     tmp |= (uint8_t)IO_Pin;
 1223              		.loc 1 502 0
 1224 001e 0443     		orrs	r4, r4, r0
 1225 0020 E1B2     		uxtb	r1, r4
 1226              	.LVL108:
 1227 0022 F7E7     		b	.L96
 1228              		.cfi_endproc
 1229              	.LFE124:
 1231 0024 AFF30080 		.section	.text.IOE_GITConfig,"ax",%progbits
 1231      AFF30080 
 1231      AFF30080 
 1232              		.align	2
 1233              		.p2align 4,,15
 1234              		.global	IOE_GITConfig
 1235              		.thumb
 1236              		.thumb_func
 1238              	IOE_GITConfig:
 1239              	.LFB122:
 408:stm32f429i_discovery_ioe.c **** {
 1240              		.loc 1 408 0
 1241              		.cfi_startproc
 1242              		@ args = 0, pretend = 0, frame = 0
 1243              		@ frame_needed = 0, uses_anonymous_args = 0
 1244              	.LVL109:
 1245 0000 38B5     		push	{r3, r4, r5, lr}
 1246              	.LCFI13:
 1247              		.cfi_def_cfa_offset 16
 1248              		.cfi_offset 3, -16
 1249              		.cfi_offset 4, -12
 1250              		.cfi_offset 5, -8
 1251              		.cfi_offset 14, -4
 408:stm32f429i_discovery_ioe.c **** {
 1252              		.loc 1 408 0
 1253 0002 0446     		mov	r4, r0
 1254 0004 0D46     		mov	r5, r1
 412:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReadDeviceRegister(IOE_REG_INT_EN);
 1255              		.loc 1 412 0
 1256 0006 0A20     		movs	r0, #10
 1257              	.LVL110:
 1258 0008 FFF7FEFF 		bl	I2C_ReadDeviceRegister
 1259              	.LVL111:
 414:stm32f429i_discovery_ioe.c ****   if (NewState != DISABLE)
 1260              		.loc 1 414 0
 1261 000c 3DB9     		cbnz	r5, .L101
 422:stm32f429i_discovery_ioe.c ****     tmp &= ~(uint8_t)Global_IT;
 1262              		.loc 1 422 0
 1263 000e 20EA0404 		bic	r4, r0, r4
 1264 0012 E1B2     		uxtb	r1, r4
 1265              	.LVL112:
 1266              	.L100:
 425:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_INT_EN, tmp);
 1267              		.loc 1 425 0
 1268 0014 0A20     		movs	r0, #10
 1269 0016 FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1270              	.LVL113:
 429:stm32f429i_discovery_ioe.c **** }
 1271              		.loc 1 429 0
 1272 001a 0020     		movs	r0, #0
 1273 001c 38BD     		pop	{r3, r4, r5, pc}
 1274              	.LVL114:
 1275              	.L101:
 417:stm32f429i_discovery_ioe.c ****     tmp |= (uint8_t)Global_IT;  
 1276              		.loc 1 417 0
 1277 001e 0443     		orrs	r4, r4, r0
 1278 0020 E1B2     		uxtb	r1, r4
 1279              	.LVL115:
 1280 0022 F7E7     		b	.L100
 1281              		.cfi_endproc
 1282              	.LFE122:
 1284 0024 AFF30080 		.section	.text.IOE_GITCmd,"ax",%progbits
 1284      AFF30080 
 1284      AFF30080 
 1285              		.align	2
 1286              		.p2align 4,,15
 1287              		.global	IOE_GITCmd
 1288              		.thumb
 1289              		.thumb_func
 1291              	IOE_GITCmd:
 1292              	.LFB121:
 371:stm32f429i_discovery_ioe.c **** {
 1293              		.loc 1 371 0
 1294              		.cfi_startproc
 1295              		@ args = 0, pretend = 0, frame = 0
 1296              		@ frame_needed = 0, uses_anonymous_args = 0
 1297              	.LVL116:
 1298 0000 10B5     		push	{r4, lr}
 1299              	.LCFI14:
 1300              		.cfi_def_cfa_offset 8
 1301              		.cfi_offset 4, -8
 1302              		.cfi_offset 14, -4
 371:stm32f429i_discovery_ioe.c **** {
 1303              		.loc 1 371 0
 1304 0002 0446     		mov	r4, r0
 375:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReadDeviceRegister(IOE_REG_INT_CTRL);
 1305              		.loc 1 375 0
 1306 0004 0920     		movs	r0, #9
 1307              	.LVL117:
 1308 0006 FFF7FEFF 		bl	I2C_ReadDeviceRegister
 1309              	.LVL118:
 377:stm32f429i_discovery_ioe.c ****   if (NewState != DISABLE)
 1310              		.loc 1 377 0
 1311 000a 34B9     		cbnz	r4, .L105
 385:stm32f429i_discovery_ioe.c ****     tmp &= ~(uint8_t)IOE_GIT_EN;
 1312              		.loc 1 385 0
 1313 000c 00F0FE01 		and	r1, r0, #254
 1314              	.LVL119:
 1315              	.L104:
 389:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_INT_CTRL, tmp);
 1316              		.loc 1 389 0
 1317 0010 0920     		movs	r0, #9
 1318 0012 FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1319              	.LVL120:
 393:stm32f429i_discovery_ioe.c **** }
 1320              		.loc 1 393 0
 1321 0016 0020     		movs	r0, #0
 1322 0018 10BD     		pop	{r4, pc}
 1323              	.LVL121:
 1324              	.L105:
 380:stm32f429i_discovery_ioe.c ****     tmp |= (uint8_t)IOE_GIT_EN;
 1325              		.loc 1 380 0
 1326 001a 40F00101 		orr	r1, r0, #1
 1327 001e C9B2     		uxtb	r1, r1
 1328              	.LVL122:
 1329 0020 F6E7     		b	.L104
 1330              		.cfi_endproc
 1331              	.LFE121:
 1333 0022 00BFAFF3 		.section	.text.IOE_TPITConfig,"ax",%progbits
 1333      0080AFF3 
 1333      0080AFF3 
 1333      0080
 1334              		.align	2
 1335              		.p2align 4,,15
 1336              		.global	IOE_TPITConfig
 1337              		.thumb
 1338              		.thumb_func
 1340              	IOE_TPITConfig:
 1341              	.LFB113:
 159:stm32f429i_discovery_ioe.c **** {    
 1342              		.loc 1 159 0
 1343              		.cfi_startproc
 1344              		@ args = 0, pretend = 0, frame = 0
 1345              		@ frame_needed = 0, uses_anonymous_args = 0
 1346 0000 08B5     		push	{r3, lr}
 1347              	.LCFI15:
 1348              		.cfi_def_cfa_offset 8
 1349              		.cfi_offset 3, -8
 1350              		.cfi_offset 14, -4
 161:stm32f429i_discovery_ioe.c ****   IOE_GITCmd(ENABLE);     
 1351              		.loc 1 161 0
 1352 0002 0120     		movs	r0, #1
 1353 0004 FFF7FEFF 		bl	IOE_GITCmd
 1354              	.LVL123:
 164:stm32f429i_discovery_ioe.c ****   IOE_GITConfig((uint8_t)(IOE_GIT_TOUCH | IOE_GIT_FTH | IOE_GIT_FOV), ENABLE);    
 1355              		.loc 1 164 0
 1356 0008 0121     		movs	r1, #1
 1357 000a 0720     		movs	r0, #7
 1358 000c FFF7FEFF 		bl	IOE_GITConfig
 1359              	.LVL124:
 167:stm32f429i_discovery_ioe.c ****   I2C_ReadDeviceRegister(IOE_REG_GPIO_INT_STA); 
 1360              		.loc 1 167 0
 1361 0010 0D20     		movs	r0, #13
 1362 0012 FFF7FEFF 		bl	I2C_ReadDeviceRegister
 1363              	.LVL125:
 171:stm32f429i_discovery_ioe.c **** }
 1364              		.loc 1 171 0
 1365 0016 0020     		movs	r0, #0
 1366 0018 08BD     		pop	{r3, pc}
 1367              		.cfi_endproc
 1368              	.LFE113:
 1370 001a 00BFAFF3 		.section	.text.IOE_FnctCmd,"ax",%progbits
 1370      0080
 1371              		.align	2
 1372              		.p2align 4,,15
 1373              		.global	IOE_FnctCmd
 1374              		.thumb
 1375              		.thumb_func
 1377              	IOE_FnctCmd:
 1378              	.LFB120:
 340:stm32f429i_discovery_ioe.c **** {
 1379              		.loc 1 340 0
 1380              		.cfi_startproc
 1381              		@ args = 0, pretend = 0, frame = 0
 1382              		@ frame_needed = 0, uses_anonymous_args = 0
 1383              	.LVL126:
 1384 0000 38B5     		push	{r3, r4, r5, lr}
 1385              	.LCFI16:
 1386              		.cfi_def_cfa_offset 16
 1387              		.cfi_offset 3, -16
 1388              		.cfi_offset 4, -12
 1389              		.cfi_offset 5, -8
 1390              		.cfi_offset 14, -4
 340:stm32f429i_discovery_ioe.c **** {
 1391              		.loc 1 340 0
 1392 0002 0446     		mov	r4, r0
 1393 0004 0D46     		mov	r5, r1
 344:stm32f429i_discovery_ioe.c ****   tmp = I2C_ReadDeviceRegister(IOE_REG_SYS_CTRL2);
 1394              		.loc 1 344 0
 1395 0006 0420     		movs	r0, #4
 1396              	.LVL127:
 1397 0008 FFF7FEFF 		bl	I2C_ReadDeviceRegister
 1398              	.LVL128:
 346:stm32f429i_discovery_ioe.c ****   if (NewState != DISABLE)
 1399              		.loc 1 346 0
 1400 000c 35B9     		cbnz	r5, .L110
 354:stm32f429i_discovery_ioe.c ****     tmp |= (uint8_t)Fct;  
 1401              		.loc 1 354 0
 1402 000e 0443     		orrs	r4, r4, r0
 1403 0010 E1B2     		uxtb	r1, r4
 1404              	.LVL129:
 1405              	.L109:
 358:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_SYS_CTRL2, tmp);
 1406              		.loc 1 358 0
 1407 0012 0420     		movs	r0, #4
 1408 0014 FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1409              	.LVL130:
 362:stm32f429i_discovery_ioe.c **** }
 1410              		.loc 1 362 0
 1411 0018 0020     		movs	r0, #0
 1412 001a 38BD     		pop	{r3, r4, r5, pc}
 1413              	.LVL131:
 1414              	.L110:
 349:stm32f429i_discovery_ioe.c ****     tmp &= ~(uint8_t)Fct;
 1415              		.loc 1 349 0
 1416 001c 20EA0404 		bic	r4, r0, r4
 1417 0020 E1B2     		uxtb	r1, r4
 1418              	.LVL132:
 1419 0022 F6E7     		b	.L109
 1420              		.cfi_endproc
 1421              	.LFE120:
 1423 0024 AFF30080 		.section	.text.IOE_TP_Config,"ax",%progbits
 1423      AFF30080 
 1423      AFF30080 
 1424              		.align	2
 1425              		.p2align 4,,15
 1426              		.global	IOE_TP_Config
 1427              		.thumb
 1428              		.thumb_func
 1430              	IOE_TP_Config:
 1431              	.LFB123:
 437:stm32f429i_discovery_ioe.c **** { 
 1432              		.loc 1 437 0
 1433              		.cfi_startproc
 1434              		@ args = 0, pretend = 0, frame = 8
 1435              		@ frame_needed = 0, uses_anonymous_args = 0
 1436 0000 00B5     		push	{lr}
 1437              	.LCFI17:
 1438              		.cfi_def_cfa_offset 4
 1439              		.cfi_offset 14, -4
 439:stm32f429i_discovery_ioe.c ****   IOE_FnctCmd(IOE_TP_FCT, ENABLE);
 1440              		.loc 1 439 0
 1441 0002 0121     		movs	r1, #1
 437:stm32f429i_discovery_ioe.c **** { 
 1442              		.loc 1 437 0
 1443 0004 83B0     		sub	sp, sp, #12
 1444              	.LCFI18:
 1445              		.cfi_def_cfa_offset 16
 439:stm32f429i_discovery_ioe.c ****   IOE_FnctCmd(IOE_TP_FCT, ENABLE);
 1446              		.loc 1 439 0
 1447 0006 0220     		movs	r0, #2
 1448 0008 FFF7FEFF 		bl	IOE_FnctCmd
 1449              	.LVL133:
 442:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_ADC_CTRL1, 0x49);
 1450              		.loc 1 442 0
 1451 000c 2020     		movs	r0, #32
 1452 000e 4921     		movs	r1, #73
 1453 0010 FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1454              	.LVL134:
 1455              	.LBB22:
 1456              	.LBB23:
1354:stm32f429i_discovery_ioe.c **** #endif /* !USE_TIMEOUT_USER_CALLBACK */
1355:stm32f429i_discovery_ioe.c **** 
1356:stm32f429i_discovery_ioe.c **** #ifndef USE_Delay
1357:stm32f429i_discovery_ioe.c **** /**
1358:stm32f429i_discovery_ioe.c ****   * @brief  Inserts a delay time.
1359:stm32f429i_discovery_ioe.c ****   * @param  nCount: specifies the delay time length.
1360:stm32f429i_discovery_ioe.c ****   * @retval None
1361:stm32f429i_discovery_ioe.c ****   */
1362:stm32f429i_discovery_ioe.c **** static void delay(__IO uint32_t nCount)
1363:stm32f429i_discovery_ioe.c **** {
1364:stm32f429i_discovery_ioe.c ****   __IO uint32_t index = 0; 
1365:stm32f429i_discovery_ioe.c ****   for(index = (100000 * nCount); index != 0; index--)
 1457              		.loc 1 1365 0
 1458 0014 4FF45463 		mov	r3, #3392
 1459              	.LVL135:
 1460 0018 C0F20303 		movt	r3, 3
 1461              	.LVL136:
1364:stm32f429i_discovery_ioe.c ****   __IO uint32_t index = 0; 
 1462              		.loc 1 1364 0
 1463 001c 0022     		movs	r2, #0
 1464 001e 0192     		str	r2, [sp, #4]
 1465              	.LVL137:
 1466              		.loc 1 1365 0
 1467 0020 0193     		str	r3, [sp, #4]
 1468 0022 0198     		ldr	r0, [sp, #4]
 1469 0024 28B1     		cbz	r0, .L113
 1470              	.L114:
 1471 0026 0199     		ldr	r1, [sp, #4]
 1472 0028 4B1E     		subs	r3, r1, #1
 1473              	.LVL138:
 1474 002a 0193     		str	r3, [sp, #4]
 1475              	.LVL139:
 1476 002c 019A     		ldr	r2, [sp, #4]
 1477 002e 002A     		cmp	r2, #0
 1478 0030 F9D1     		bne	.L114
 1479              	.L113:
 1480              	.LBE23:
 1481              	.LBE22:
 448:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_ADC_CTRL2, 0x01);
 1482              		.loc 1 448 0
 1483 0032 0121     		movs	r1, #1
 1484 0034 2120     		movs	r0, #33
 1485 0036 FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1486              	.LVL140:
 451:stm32f429i_discovery_ioe.c ****   IOE_IOAFConfig((uint8_t)TOUCH_IO_ALL, DISABLE);
 1487              		.loc 1 451 0
 1488 003a 0021     		movs	r1, #0
 1489 003c 1E20     		movs	r0, #30
 1490 003e FFF7FEFF 		bl	IOE_IOAFConfig
 1491              	.LVL141:
 454:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_TP_CFG, 0x9A);   
 1492              		.loc 1 454 0
 1493 0042 9A21     		movs	r1, #154
 1494 0044 4120     		movs	r0, #65
 1495 0046 FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1496              	.LVL142:
 457:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_FIFO_TH, 0x01);
 1497              		.loc 1 457 0
 1498 004a 0121     		movs	r1, #1
 1499 004c 4A20     		movs	r0, #74
 1500 004e FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1501              	.LVL143:
 460:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_FIFO_STA, 0x01);
 1502              		.loc 1 460 0
 1503 0052 0121     		movs	r1, #1
 1504 0054 4B20     		movs	r0, #75
 1505 0056 FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1506              	.LVL144:
 463:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_FIFO_STA, 0x00);
 1507              		.loc 1 463 0
 1508 005a 0021     		movs	r1, #0
 1509 005c 4B20     		movs	r0, #75
 1510 005e FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1511              	.LVL145:
 466:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_TP_FRACT_XYZ, 0x01);
 1512              		.loc 1 466 0
 1513 0062 0121     		movs	r1, #1
 1514 0064 5620     		movs	r0, #86
 1515 0066 FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1516              	.LVL146:
 469:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_TP_I_DRIVE, 0x01);
 1517              		.loc 1 469 0
 1518 006a 0121     		movs	r1, #1
 1519 006c 5820     		movs	r0, #88
 1520 006e FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1521              	.LVL147:
 473:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_TP_CTRL, 0x03);
 1522              		.loc 1 473 0
 1523 0072 0321     		movs	r1, #3
 1524 0074 4020     		movs	r0, #64
 1525 0076 FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1526              	.LVL148:
 476:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_INT_STA, 0xFF); 
 1527              		.loc 1 476 0
 1528 007a FF21     		movs	r1, #255
 1529 007c 0B20     		movs	r0, #11
 1530 007e FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1531              	.LVL149:
 479:stm32f429i_discovery_ioe.c ****   TP_State.TouchDetected = TP_State.X = TP_State.Y = TP_State.Z = 0;
 1532              		.loc 1 479 0
 1533 0082 0449     		ldr	r1, .L117
 1534 0084 0020     		movs	r0, #0
 1535 0086 C880     		strh	r0, [r1, #6]	@ movhi
 1536 0088 8880     		strh	r0, [r1, #4]	@ movhi
 1537 008a 4880     		strh	r0, [r1, #2]	@ movhi
 1538 008c 0880     		strh	r0, [r1, #0]	@ movhi
 483:stm32f429i_discovery_ioe.c **** }
 1539              		.loc 1 483 0
 1540 008e 03B0     		add	sp, sp, #12
 1541 0090 00BD     		pop	{pc}
 1542              	.L118:
 1543 0092 00BF     		.align	2
 1544              	.L117:
 1545 0094 00000000 		.word	.LANCHOR1
 1546              		.cfi_endproc
 1547              	.LFE123:
 1549 0098 AFF30080 		.section	.text.IOE_Reset,"ax",%progbits
 1549      AFF30080 
 1550              		.align	2
 1551              		.p2align 4,,15
 1552              		.global	IOE_Reset
 1553              		.thumb
 1554              		.thumb_func
 1556              	IOE_Reset:
 1557              	.LFB118:
 297:stm32f429i_discovery_ioe.c **** {
 1558              		.loc 1 297 0
 1559              		.cfi_startproc
 1560              		@ args = 0, pretend = 0, frame = 8
 1561              		@ frame_needed = 0, uses_anonymous_args = 0
 1562 0000 00B5     		push	{lr}
 1563              	.LCFI19:
 1564              		.cfi_def_cfa_offset 4
 1565              		.cfi_offset 14, -4
 299:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_SYS_CTRL1, 0x02);
 1566              		.loc 1 299 0
 1567 0002 0320     		movs	r0, #3
 297:stm32f429i_discovery_ioe.c **** {
 1568              		.loc 1 297 0
 1569 0004 83B0     		sub	sp, sp, #12
 1570              	.LCFI20:
 1571              		.cfi_def_cfa_offset 16
 299:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_SYS_CTRL1, 0x02);
 1572              		.loc 1 299 0
 1573 0006 0221     		movs	r1, #2
 1574 0008 FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1575              	.LVL150:
 1576              	.LBB24:
 1577              	.LBB25:
 1578              		.loc 1 1365 0
 1579 000c 4FF45463 		mov	r3, #3392
 1580              	.LVL151:
 1581 0010 C0F20303 		movt	r3, 3
 1582              	.LVL152:
1364:stm32f429i_discovery_ioe.c ****   __IO uint32_t index = 0; 
 1583              		.loc 1 1364 0
 1584 0014 0022     		movs	r2, #0
 1585 0016 0192     		str	r2, [sp, #4]
 1586              	.LVL153:
 1587              		.loc 1 1365 0
 1588 0018 0193     		str	r3, [sp, #4]
 1589 001a 0198     		ldr	r0, [sp, #4]
 1590 001c 28B1     		cbz	r0, .L121
 1591              	.L122:
 1592 001e 0199     		ldr	r1, [sp, #4]
 1593 0020 4B1E     		subs	r3, r1, #1
 1594              	.LVL154:
 1595 0022 0193     		str	r3, [sp, #4]
 1596              	.LVL155:
 1597 0024 019A     		ldr	r2, [sp, #4]
 1598 0026 002A     		cmp	r2, #0
 1599 0028 F9D1     		bne	.L122
 1600              	.L121:
 1601              	.LBE25:
 1602              	.LBE24:
 305:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_SYS_CTRL1, 0x00);
 1603              		.loc 1 305 0
 1604 002a 0021     		movs	r1, #0
 1605 002c 0320     		movs	r0, #3
 1606 002e FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1607              	.LVL156:
 309:stm32f429i_discovery_ioe.c **** }
 1608              		.loc 1 309 0
 1609 0032 0020     		movs	r0, #0
 1610 0034 03B0     		add	sp, sp, #12
 1611 0036 00BD     		pop	{pc}
 1612              		.cfi_endproc
 1613              	.LFE118:
 1615 0038 AFF30080 		.section	.text.IOE_ClearGITPending,"ax",%progbits
 1615      AFF30080 
 1616              		.align	2
 1617              		.p2align 4,,15
 1618              		.global	IOE_ClearGITPending
 1619              		.thumb
 1620              		.thumb_func
 1622              	IOE_ClearGITPending:
 1623              	.LFB116:
 255:stm32f429i_discovery_ioe.c **** {
 1624              		.loc 1 255 0
 1625              		.cfi_startproc
 1626              		@ args = 0, pretend = 0, frame = 0
 1627              		@ frame_needed = 0, uses_anonymous_args = 0
 1628              	.LVL157:
 1629 0000 0146     		mov	r1, r0
 1630 0002 08B5     		push	{r3, lr}
 1631              	.LCFI21:
 1632              		.cfi_def_cfa_offset 8
 1633              		.cfi_offset 3, -8
 1634              		.cfi_offset 14, -4
 257:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_INT_STA, Global_IT); 
 1635              		.loc 1 257 0
 1636 0004 0B20     		movs	r0, #11
 1637              	.LVL158:
 1638 0006 FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1639              	.LVL159:
 261:stm32f429i_discovery_ioe.c **** }
 1640              		.loc 1 261 0
 1641 000a 0020     		movs	r0, #0
 1642 000c 08BD     		pop	{r3, pc}
 1643              		.cfi_endproc
 1644              	.LFE116:
 1646 000e 00BF     		.section	.text.IOE_TP_GetState,"ax",%progbits
 1647              		.align	2
 1648              		.p2align 4,,15
 1649              		.global	IOE_TP_GetState
 1650              		.thumb
 1651              		.thumb_func
 1653              	IOE_TP_GetState:
 1654              	.LFB114:
 179:stm32f429i_discovery_ioe.c **** {
 1655              		.loc 1 179 0
 1656              		.cfi_startproc
 1657              		@ args = 0, pretend = 0, frame = 0
 1658              		@ frame_needed = 0, uses_anonymous_args = 0
 1659 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1660              	.LCFI22:
 1661              		.cfi_def_cfa_offset 24
 1662              		.cfi_offset 3, -24
 1663              		.cfi_offset 4, -20
 1664              		.cfi_offset 5, -16
 1665              		.cfi_offset 6, -12
 1666              		.cfi_offset 7, -8
 1667              		.cfi_offset 14, -4
 184:stm32f429i_discovery_ioe.c ****   TP_State.TouchDetected = (I2C_ReadDeviceRegister(IOE_REG_TP_CTRL) & 0x80);
 1668              		.loc 1 184 0
 1669 0002 4020     		movs	r0, #64
 1670 0004 FFF7FEFF 		bl	I2C_ReadDeviceRegister
 1671              	.LVL160:
 1672 0008 344C     		ldr	r4, .L142
 1673 000a 20F07F00 		bic	r0, r0, #127
 1674 000e C1B2     		uxtb	r1, r0
 1675 0010 2180     		strh	r1, [r4, #0]	@ movhi
 186:stm32f429i_discovery_ioe.c ****   if(TP_State.TouchDetected) 
 1676              		.loc 1 186 0
 1677 0012 99B9     		cbnz	r1, .L127
 1678 0014 324B     		ldr	r3, .L142+4
 1679 0016 3348     		ldr	r0, .L142+8
 1680 0018 1A68     		ldr	r2, [r3, #0]
 1681 001a 0368     		ldr	r3, [r0, #0]
 1682              	.L128:
 1683              	.LBB32:
 1684              	.LBB33:
 896:stm32f429i_discovery_ioe.c ****   z = I2C_ReadDataBuffer(IOE_REG_TP_DATA_Z);
 1685              		.loc 1 896 0
 1686 001c 5120     		movs	r0, #81
 1687              	.LBE33:
 1688              	.LBE32:
 199:stm32f429i_discovery_ioe.c ****   TP_State.X = _x;
 1689              		.loc 1 199 0
 1690 001e 6280     		strh	r2, [r4, #2]	@ movhi
 202:stm32f429i_discovery_ioe.c ****   TP_State.Y = _y;
 1691              		.loc 1 202 0
 1692 0020 A380     		strh	r3, [r4, #4]	@ movhi
 1693              	.LBB35:
 1694              	.LBB34:
 896:stm32f429i_discovery_ioe.c ****   z = I2C_ReadDataBuffer(IOE_REG_TP_DATA_Z);
 1695              		.loc 1 896 0
 1696 0022 FFF7FEFF 		bl	I2C_ReadDataBuffer
 1697              	.LVL161:
 1698              	.LBE34:
 1699              	.LBE35:
 207:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_FIFO_STA, 0x01);
 1700              		.loc 1 207 0
 1701 0026 0121     		movs	r1, #1
 204:stm32f429i_discovery_ioe.c ****   TP_State.Z = IOE_TP_Read_Z();  
 1702              		.loc 1 204 0
 1703 0028 E080     		strh	r0, [r4, #6]	@ movhi
 207:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_FIFO_STA, 0x01);
 1704              		.loc 1 207 0
 1705 002a 4B20     		movs	r0, #75
 1706              	.LVL162:
 1707 002c FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1708              	.LVL163:
 208:stm32f429i_discovery_ioe.c ****   I2C_WriteDeviceRegister(IOE_REG_FIFO_STA, 0x00);
 1709              		.loc 1 208 0
 1710 0030 4B20     		movs	r0, #75
 1711 0032 0021     		movs	r1, #0
 1712 0034 FFF7FEFF 		bl	I2C_WriteDeviceRegister
 1713              	.LVL164:
 212:stm32f429i_discovery_ioe.c **** }
 1714              		.loc 1 212 0
 1715 0038 2848     		ldr	r0, .L142
 1716 003a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1717              	.L127:
 1718              	.LBB36:
 1719              	.LBB37:
 824:stm32f429i_discovery_ioe.c ****   x = I2C_ReadDataBuffer(IOE_REG_TP_DATA_X);
 1720              		.loc 1 824 0
 1721 003c 4D20     		movs	r0, #77
 1722 003e FFF7FEFF 		bl	I2C_ReadDataBuffer
 1723              	.LVL165:
 827:stm32f429i_discovery_ioe.c ****   if(x <= 3000)
 1724              		.loc 1 827 0
 1725 0042 40F6B832 		movw	r2, #3000
 1726 0046 9042     		cmp	r0, r2
 1727 0048 3FDD     		ble	.L141
 833:stm32f429i_discovery_ioe.c ****    x = 3800 - x;
 1728              		.loc 1 833 0
 1729 004a C0F56D66 		rsb	r6, r0, #3792
 1730 004e 0836     		adds	r6, r6, #8
 1731              	.LVL166:
 1732              	.L130:
 837:stm32f429i_discovery_ioe.c ****   xr = x / 15;
 1733              		.loc 1 837 0
 1734 0050 48F68905 		movw	r5, #34953
 1735 0054 C8F68805 		movt	r5, 34952
 1736 0058 85FB0621 		smull	r2, r1, r5, r6
 1737 005c F017     		asrs	r0, r6, #31
 1738 005e 8B19     		adds	r3, r1, r6
 1739 0060 C0EBE305 		rsb	r5, r0, r3, asr #3
 1740              	.LVL167:
 840:stm32f429i_discovery_ioe.c ****   if(xr <= 0)
 1741              		.loc 1 840 0
 1742 0064 002D     		cmp	r5, #0
 1743 0066 36DD     		ble	.L137
 1744 0068 F02D     		cmp	r5, #240
 1745 006a C8BF     		it	gt
 1746 006c EF25     		movgt	r5, #239
 1747              	.LVL168:
 1748              	.L131:
 1749              	.LBE37:
 1750              	.LBE36:
 1751              	.LBB40:
 1752              	.LBB41:
 863:stm32f429i_discovery_ioe.c ****   y = I2C_ReadDataBuffer(IOE_REG_TP_DATA_Y);
 1753              		.loc 1 863 0
 1754 006e 4F20     		movs	r0, #79
 1755 0070 FFF7FEFF 		bl	I2C_ReadDataBuffer
 1756              	.LVL169:
 870:stm32f429i_discovery_ioe.c ****   yr = y / 11;
 1757              		.loc 1 870 0
 1758 0074 4AF2E922 		movw	r2, #41705
 867:stm32f429i_discovery_ioe.c ****   y -= 360;  
 1759              		.loc 1 867 0
 1760 0078 A0F5B476 		sub	r6, r0, #360
 1761              	.LVL170:
 870:stm32f429i_discovery_ioe.c ****   yr = y / 11;
 1762              		.loc 1 870 0
 1763 007c C2F68B62 		movt	r2, 11915
 1764 0080 F317     		asrs	r3, r6, #31
 1765 0082 82FB0621 		smull	r2, r1, r2, r6
 1766 0086 C3EB6101 		rsb	r1, r3, r1, asr #1
 1767              	.LVL171:
 873:stm32f429i_discovery_ioe.c ****   if(yr <= 0)
 1768              		.loc 1 873 0
 1769 008a 0029     		cmp	r1, #0
 1770 008c 21DD     		ble	.L139
 1771 008e 40F23F10 		movw	r0, #319
 1772 0092 B1F5A07F 		cmp	r1, #320
 1773 0096 C8BF     		it	gt
 1774 0098 0146     		movgt	r1, r0
 1775              	.LVL172:
 1776              	.L132:
 1777              	.LBE41:
 1778              	.LBE40:
 190:stm32f429i_discovery_ioe.c ****     xDiff = x > _x? (x - _x): (_x - x);
 1779              		.loc 1 190 0
 1780 009a 114E     		ldr	r6, .L142+4
 1781              	.LVL173:
 191:stm32f429i_discovery_ioe.c ****     yDiff = y > _y? (y - _y): (_y - y);       
 1782              		.loc 1 191 0
 1783 009c 1148     		ldr	r0, .L142+8
 190:stm32f429i_discovery_ioe.c ****     xDiff = x > _x? (x - _x): (_x - x);
 1784              		.loc 1 190 0
 1785 009e 3268     		ldr	r2, [r6, #0]
 191:stm32f429i_discovery_ioe.c ****     yDiff = y > _y? (y - _y): (_y - y);       
 1786              		.loc 1 191 0
 1787 00a0 0368     		ldr	r3, [r0, #0]
 190:stm32f429i_discovery_ioe.c ****     xDiff = x > _x? (x - _x): (_x - x);
 1788              		.loc 1 190 0
 1789 00a2 AA42     		cmp	r2, r5
 1790 00a4 34BF     		ite	cc
 1791 00a6 C2EB0507 		rsbcc	r7, r2, r5
 1792 00aa C5EB0207 		rsbcs	r7, r5, r2
 1793              	.LVL174:
 191:stm32f429i_discovery_ioe.c ****     yDiff = y > _y? (y - _y): (_y - y);       
 1794              		.loc 1 191 0
 1795 00ae 8B42     		cmp	r3, r1
 1796 00b0 34BF     		ite	cc
 1797 00b2 C3EB010E 		rsbcc	lr, r3, r1
 1798 00b6 C1EB030E 		rsbcs	lr, r1, r3
 1799              	.LVL175:
 192:stm32f429i_discovery_ioe.c ****     if (xDiff + yDiff > 5)
 1800              		.loc 1 192 0
 1801 00ba 7744     		add	r7, lr, r7
 1802              	.LVL176:
 1803 00bc 052F     		cmp	r7, #5
 1804 00be ADD9     		bls	.L128
 194:stm32f429i_discovery_ioe.c ****       _x = x;
 1805              		.loc 1 194 0
 1806 00c0 3560     		str	r5, [r6, #0]
 195:stm32f429i_discovery_ioe.c ****       _y = y;       
 1807              		.loc 1 195 0
 1808 00c2 0160     		str	r1, [r0, #0]
 1809 00c4 0B46     		mov	r3, r1
 1810 00c6 2A46     		mov	r2, r5
 1811 00c8 A8E7     		b	.L128
 1812              	.LVL177:
 1813              	.L141:
 1814              	.LBB43:
 1815              	.LBB38:
 829:stm32f429i_discovery_ioe.c ****   x = 3870 - x;
 1816              		.loc 1 829 0
 1817 00ca C0F57166 		rsb	r6, r0, #3856
 1818 00ce 0E36     		adds	r6, r6, #14
 1819              	.LVL178:
 1820 00d0 BEE7     		b	.L130
 1821              	.LVL179:
 1822              	.L139:
 1823              	.LBE38:
 1824              	.LBE43:
 1825              	.LBB44:
 1826              	.LBB42:
 873:stm32f429i_discovery_ioe.c ****   if(yr <= 0)
 1827              		.loc 1 873 0
 1828 00d2 0021     		movs	r1, #0
 1829              	.LVL180:
 1830 00d4 E1E7     		b	.L132
 1831              	.LVL181:
 1832              	.L137:
 1833              	.LBE42:
 1834              	.LBE44:
 1835              	.LBB45:
 1836              	.LBB39:
 840:stm32f429i_discovery_ioe.c ****   if(xr <= 0)
 1837              		.loc 1 840 0
 1838 00d6 0025     		movs	r5, #0
 1839              	.LVL182:
 1840 00d8 C9E7     		b	.L131
 1841              	.L143:
 1842 00da 00BF     		.align	2
 1843              	.L142:
 1844 00dc 00000000 		.word	.LANCHOR1
 1845 00e0 00000000 		.word	.LANCHOR2
 1846 00e4 00000000 		.word	.LANCHOR3
 1847              	.LBE39:
 1848              	.LBE45:
 1849              		.cfi_endproc
 1850              	.LFE114:
 1852              		.section	.text.I2C_DMA_ReadDataBuffer,"ax",%progbits
 1853              		.align	2
 1854              		.p2align 4,,15
 1855              		.global	I2C_DMA_ReadDataBuffer
 1856              		.thumb
 1857              		.thumb_func
 1859              	I2C_DMA_ReadDataBuffer:
 1860              	.LFB127:
 719:stm32f429i_discovery_ioe.c **** { 
 1861              		.loc 1 719 0
 1862              		.cfi_startproc
 1863              		@ args = 0, pretend = 0, frame = 8
 1864              		@ frame_needed = 0, uses_anonymous_args = 0
 1865              	.LVL183:
 1866 0000 30B5     		push	{r4, r5, lr}
 1867              	.LCFI23:
 1868              		.cfi_def_cfa_offset 12
 1869              		.cfi_offset 4, -12
 1870              		.cfi_offset 5, -8
 1871              		.cfi_offset 14, -4
 1872 0002 83B0     		sub	sp, sp, #12
 1873              	.LCFI24:
 1874              		.cfi_def_cfa_offset 24
 721:stm32f429i_discovery_ioe.c ****   uint8_t IOE_BufferRX[2] = {0x00, 0x00};  
 1875              		.loc 1 721 0
 1876 0004 0023     		movs	r3, #0
 724:stm32f429i_discovery_ioe.c ****   IOE_DMA_Config(IOE_DMA_RX, (uint8_t*)IOE_BufferRX);
 1877              		.loc 1 724 0
 1878 0006 01A9     		add	r1, sp, #4
 719:stm32f429i_discovery_ioe.c **** { 
 1879              		.loc 1 719 0
 1880 0008 0546     		mov	r5, r0
 724:stm32f429i_discovery_ioe.c ****   IOE_DMA_Config(IOE_DMA_RX, (uint8_t*)IOE_BufferRX);
 1881              		.loc 1 724 0
 1882 000a 0120     		movs	r0, #1
 1883              	.LVL184:
 721:stm32f429i_discovery_ioe.c ****   uint8_t IOE_BufferRX[2] = {0x00, 0x00};  
 1884              		.loc 1 721 0
 1885 000c 8DF80430 		strb	r3, [sp, #4]
 1886 0010 8DF80530 		strb	r3, [sp, #5]
 724:stm32f429i_discovery_ioe.c ****   IOE_DMA_Config(IOE_DMA_RX, (uint8_t*)IOE_BufferRX);
 1887              		.loc 1 724 0
 1888 0014 FFF7FEFF 		bl	IOE_DMA_Config
 1889              	.LVL185:
 727:stm32f429i_discovery_ioe.c ****   I2C_DMALastTransferCmd(IOE_I2C, ENABLE);
 1890              		.loc 1 727 0
 1891 0018 4FF4B840 		mov	r0, #23552
 1892 001c C4F20000 		movt	r0, 16384
 1893 0020 0121     		movs	r1, #1
 1894 0022 FFF7FEFF 		bl	I2C_DMALastTransferCmd
 1895              	.LVL186:
 730:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 1896              		.loc 1 730 0
 1897 0026 4FF4B840 		mov	r0, #23552
 1898 002a C4F20000 		movt	r0, 16384
 1899 002e 0121     		movs	r1, #1
 733:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 1900              		.loc 1 733 0
 1901 0030 694C     		ldr	r4, .L173
 730:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 1902              		.loc 1 730 0
 1903 0032 FFF7FEFF 		bl	I2C_GenerateSTART
 1904              	.LVL187:
 733:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 1905              		.loc 1 733 0
 1906 0036 4FF44050 		mov	r0, #12288
 1907 003a 2060     		str	r0, [r4, #0]
 1908              	.L145:
 734:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
 1909              		.loc 1 734 0 discriminator 1
 1910 003c 4FF4B840 		mov	r0, #23552
 1911 0040 0121     		movs	r1, #1
 1912 0042 C4F20000 		movt	r0, 16384
 1913 0046 C1F20001 		movt	r1, 4096
 1914 004a FFF7FEFF 		bl	I2C_GetFlagStatus
 1915              	.LVL188:
 1916 004e 40B9     		cbnz	r0, .L168
 736:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 1917              		.loc 1 736 0
 1918 0050 2368     		ldr	r3, [r4, #0]
 1919 0052 5A1E     		subs	r2, r3, #1
 1920 0054 2260     		str	r2, [r4, #0]
 1921 0056 002B     		cmp	r3, #0
 1922 0058 F0D1     		bne	.L145
 1923              	.L167:
 789:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 1924              		.loc 1 789 0 discriminator 1
 1925 005a FFF7FEFF 		bl	IOE_TimeoutUserCallback
 1926              	.LVL189:
 1927              	.L146:
 811:stm32f429i_discovery_ioe.c **** }
 1928              		.loc 1 811 0
 1929 005e 03B0     		add	sp, sp, #12
 1930 0060 30BD     		pop	{r4, r5, pc}
 1931              	.LVL190:
 1932              	.L168:
 740:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Transmitter);
 1933              		.loc 1 740 0
 1934 0062 4FF4B840 		mov	r0, #23552
 1935 0066 8221     		movs	r1, #130
 1936 0068 C4F20000 		movt	r0, 16384
 1937 006c 0022     		movs	r2, #0
 1938 006e FFF7FEFF 		bl	I2C_Send7bitAddress
 1939              	.LVL191:
 743:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 1940              		.loc 1 743 0
 1941 0072 4FF44051 		mov	r1, #12288
 1942 0076 2160     		str	r1, [r4, #0]
 1943              	.L148:
 744:stm32f429i_discovery_ioe.c ****   while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 1944              		.loc 1 744 0 discriminator 1
 1945 0078 4FF4B840 		mov	r0, #23552
 1946 007c 8221     		movs	r1, #130
 1947 007e C4F20000 		movt	r0, 16384
 1948 0082 C0F20701 		movt	r1, 7
 1949 0086 FFF7FEFF 		bl	I2C_CheckEvent
 1950              	.LVL192:
 1951 008a 28B9     		cbnz	r0, .L169
 746:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 1952              		.loc 1 746 0
 1953 008c 2068     		ldr	r0, [r4, #0]
 1954 008e 411E     		subs	r1, r0, #1
 1955 0090 2160     		str	r1, [r4, #0]
 1956 0092 0028     		cmp	r0, #0
 1957 0094 F0D1     		bne	.L148
 1958 0096 E0E7     		b	.L167
 1959              	.L169:
 750:stm32f429i_discovery_ioe.c ****   I2C_SendData(IOE_I2C, RegisterAddr);  
 1960              		.loc 1 750 0
 1961 0098 4FF4B840 		mov	r0, #23552
 1962 009c C4F20000 		movt	r0, 16384
 1963 00a0 E9B2     		uxtb	r1, r5
 1964 00a2 FFF7FEFF 		bl	I2C_SendData
 1965              	.LVL193:
 753:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 1966              		.loc 1 753 0
 1967 00a6 4FF44052 		mov	r2, #12288
 1968 00aa 2260     		str	r2, [r4, #0]
 1969              	.L150:
 754:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF))) 
 1970              		.loc 1 754 0 discriminator 1
 1971 00ac 4FF4B840 		mov	r0, #23552
 1972 00b0 8021     		movs	r1, #128
 1973 00b2 C1F20001 		movt	r1, 4096
 1974 00b6 C4F20000 		movt	r0, 16384
 1975 00ba FFF7FEFF 		bl	I2C_GetFlagStatus
 1976              	.LVL194:
 1977 00be 0421     		movs	r1, #4
 1978 00c0 C1F20001 		movt	r1, 4096
 1979 00c4 60B9     		cbnz	r0, .L154
 754:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF))) 
 1980              		.loc 1 754 0 is_stmt 0 discriminator 2
 1981 00c6 4FF4B840 		mov	r0, #23552
 1982 00ca C4F20000 		movt	r0, 16384
 1983 00ce FFF7FEFF 		bl	I2C_GetFlagStatus
 1984              	.LVL195:
 1985 00d2 28B9     		cbnz	r0, .L154
 756:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 1986              		.loc 1 756 0 is_stmt 1
 1987 00d4 2368     		ldr	r3, [r4, #0]
 1988 00d6 5A1E     		subs	r2, r3, #1
 1989 00d8 2260     		str	r2, [r4, #0]
 1990 00da 002B     		cmp	r3, #0
 1991 00dc E6D1     		bne	.L150
 1992 00de BCE7     		b	.L167
 1993              	.L154:
 760:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 1994              		.loc 1 760 0
 1995 00e0 4FF4B840 		mov	r0, #23552
 1996 00e4 C4F20000 		movt	r0, 16384
 1997 00e8 0121     		movs	r1, #1
 1998 00ea FFF7FEFF 		bl	I2C_GenerateSTART
 1999              	.LVL196:
 763:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 2000              		.loc 1 763 0
 2001 00ee 4FF44053 		mov	r3, #12288
 2002 00f2 2360     		str	r3, [r4, #0]
 2003              	.L152:
 764:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
 2004              		.loc 1 764 0 discriminator 1
 2005 00f4 4FF4B840 		mov	r0, #23552
 2006 00f8 0121     		movs	r1, #1
 2007 00fa C4F20000 		movt	r0, 16384
 2008 00fe C1F20001 		movt	r1, 4096
 2009 0102 FFF7FEFF 		bl	I2C_GetFlagStatus
 2010              	.LVL197:
 2011 0106 28B9     		cbnz	r0, .L170
 766:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2012              		.loc 1 766 0
 2013 0108 2068     		ldr	r0, [r4, #0]
 2014 010a 411E     		subs	r1, r0, #1
 2015 010c 2160     		str	r1, [r4, #0]
 2016 010e 0028     		cmp	r0, #0
 2017 0110 F0D1     		bne	.L152
 2018 0112 A2E7     		b	.L167
 2019              	.L170:
 770:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Receiver);
 2020              		.loc 1 770 0
 2021 0114 4FF4B840 		mov	r0, #23552
 2022 0118 C4F20000 		movt	r0, 16384
 2023 011c 8221     		movs	r1, #130
 2024 011e 0122     		movs	r2, #1
 2025 0120 FFF7FEFF 		bl	I2C_Send7bitAddress
 2026              	.LVL198:
 773:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 2027              		.loc 1 773 0
 2028 0124 4FF44050 		mov	r0, #12288
 2029 0128 2060     		str	r0, [r4, #0]
 2030              	.L156:
 774:stm32f429i_discovery_ioe.c ****   while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))   
 2031              		.loc 1 774 0 discriminator 1
 2032 012a 4FF4B840 		mov	r0, #23552
 2033 012e 0221     		movs	r1, #2
 2034 0130 C4F20000 		movt	r0, 16384
 2035 0134 C0F20301 		movt	r1, 3
 2036 0138 FFF7FEFF 		bl	I2C_CheckEvent
 2037              	.LVL199:
 2038 013c 28B9     		cbnz	r0, .L171
 776:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2039              		.loc 1 776 0
 2040 013e 2368     		ldr	r3, [r4, #0]
 2041 0140 5A1E     		subs	r2, r3, #1
 2042 0142 2260     		str	r2, [r4, #0]
 2043 0144 002B     		cmp	r3, #0
 2044 0146 F0D1     		bne	.L156
 2045 0148 87E7     		b	.L167
 2046              	.L171:
 780:stm32f429i_discovery_ioe.c ****   I2C_DMACmd(IOE_I2C,ENABLE);
 2047              		.loc 1 780 0
 2048 014a 4FF4B840 		mov	r0, #23552
 2049 014e C4F20000 		movt	r0, 16384
 2050 0152 0121     		movs	r1, #1
 2051 0154 FFF7FEFF 		bl	I2C_DMACmd
 2052              	.LVL200:
 783:stm32f429i_discovery_ioe.c ****   DMA_Cmd(IOE_DMA_RX_STREAM, ENABLE);
 2053              		.loc 1 783 0
 2054 0158 46F21000 		movw	r0, #24592
 2055 015c 0121     		movs	r1, #1
 2056 015e C4F20200 		movt	r0, 16386
 2057 0162 FFF7FEFF 		bl	DMA_Cmd
 2058              	.LVL201:
 786:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = 2 * TIMEOUT_MAX;
 2059              		.loc 1 786 0
 2060 0166 4FF4C041 		mov	r1, #24576
 2061 016a 2160     		str	r1, [r4, #0]
 2062              	.L158:
 787:stm32f429i_discovery_ioe.c ****   while (!DMA_GetFlagStatus(IOE_DMA_RX_STREAM, IOE_DMA_RX_TCFLAG))
 2063              		.loc 1 787 0 discriminator 1
 2064 016c 46F21000 		movw	r0, #24592
 2065 0170 2021     		movs	r1, #32
 2066 0172 C4F20200 		movt	r0, 16386
 2067 0176 C1F20001 		movt	r1, 4096
 2068 017a FFF7FEFF 		bl	DMA_GetFlagStatus
 2069              	.LVL202:
 2070 017e 28B9     		cbnz	r0, .L172
 789:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2071              		.loc 1 789 0
 2072 0180 2068     		ldr	r0, [r4, #0]
 2073 0182 411E     		subs	r1, r0, #1
 2074 0184 2160     		str	r1, [r4, #0]
 2075 0186 0028     		cmp	r0, #0
 2076 0188 F0D1     		bne	.L158
 2077 018a 66E7     		b	.L167
 2078              	.L172:
 793:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTOP(IOE_I2C, ENABLE);
 2079              		.loc 1 793 0
 2080 018c 4FF4B840 		mov	r0, #23552
 2081 0190 C4F20000 		movt	r0, 16384
 2082 0194 0121     		movs	r1, #1
 2083 0196 FFF7FEFF 		bl	I2C_GenerateSTOP
 2084              	.LVL203:
 796:stm32f429i_discovery_ioe.c ****   DMA_Cmd(IOE_DMA_RX_STREAM, DISABLE);
 2085              		.loc 1 796 0
 2086 019a 46F21000 		movw	r0, #24592
 2087 019e C4F20200 		movt	r0, 16386
 2088 01a2 0021     		movs	r1, #0
 2089 01a4 FFF7FEFF 		bl	DMA_Cmd
 2090              	.LVL204:
 799:stm32f429i_discovery_ioe.c ****   I2C_DMACmd(IOE_I2C,DISABLE);
 2091              		.loc 1 799 0
 2092 01a8 4FF4B840 		mov	r0, #23552
 2093 01ac C4F20000 		movt	r0, 16384
 2094 01b0 0021     		movs	r1, #0
 2095 01b2 FFF7FEFF 		bl	I2C_DMACmd
 2096              	.LVL205:
 802:stm32f429i_discovery_ioe.c ****   DMA_ClearFlag(IOE_DMA_RX_STREAM,IOE_DMA_RX_TCFLAG);
 2097              		.loc 1 802 0
 2098 01b6 46F21000 		movw	r0, #24592
 2099 01ba 2021     		movs	r1, #32
 2100 01bc C4F20200 		movt	r0, 16386
 2101 01c0 C1F20001 		movt	r1, 4096
 2102 01c4 FFF7FEFF 		bl	DMA_ClearFlag
 2103              	.LVL206:
 810:stm32f429i_discovery_ioe.c ****   return (uint16_t) ((uint16_t)IOE_BufferRX[0] | (uint16_t)IOE_BufferRX[1]<< 8);
 2104              		.loc 1 810 0
 2105 01c8 9DF80420 		ldrb	r2, [sp, #4]	@ zero_extendqisi2
 2106 01cc 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 2107 01d0 43EA0220 		orr	r0, r3, r2, lsl #8
 2108 01d4 43E7     		b	.L146
 2109              	.L174:
 2110 01d6 00BF     		.align	2
 2111              	.L173:
 2112 01d8 00000000 		.word	.LANCHOR0
 2113              		.cfi_endproc
 2114              	.LFE127:
 2116 01dc AFF30080 		.section	.text.I2C_DMA_ReadDeviceRegister,"ax",%progbits
 2117              		.align	2
 2118              		.p2align 4,,15
 2119              		.global	I2C_DMA_ReadDeviceRegister
 2120              		.thumb
 2121              		.thumb_func
 2123              	I2C_DMA_ReadDeviceRegister:
 2124              	.LFB126:
 624:stm32f429i_discovery_ioe.c **** {
 2125              		.loc 1 624 0
 2126              		.cfi_startproc
 2127              		@ args = 0, pretend = 0, frame = 8
 2128              		@ frame_needed = 0, uses_anonymous_args = 0
 2129              	.LVL207:
 2130 0000 30B5     		push	{r4, r5, lr}
 2131              	.LCFI25:
 2132              		.cfi_def_cfa_offset 12
 2133              		.cfi_offset 4, -12
 2134              		.cfi_offset 5, -8
 2135              		.cfi_offset 14, -4
 2136 0002 83B0     		sub	sp, sp, #12
 2137              	.LCFI26:
 2138              		.cfi_def_cfa_offset 24
 625:stm32f429i_discovery_ioe.c ****   uint8_t IOE_BufferRX[2] = {0x00, 0x00};  
 2139              		.loc 1 625 0
 2140 0004 0023     		movs	r3, #0
 628:stm32f429i_discovery_ioe.c ****   IOE_DMA_Config(IOE_DMA_RX, (uint8_t*)IOE_BufferRX);
 2141              		.loc 1 628 0
 2142 0006 01A9     		add	r1, sp, #4
 624:stm32f429i_discovery_ioe.c **** {
 2143              		.loc 1 624 0
 2144 0008 0546     		mov	r5, r0
 628:stm32f429i_discovery_ioe.c ****   IOE_DMA_Config(IOE_DMA_RX, (uint8_t*)IOE_BufferRX);
 2145              		.loc 1 628 0
 2146 000a 0120     		movs	r0, #1
 2147              	.LVL208:
 625:stm32f429i_discovery_ioe.c ****   uint8_t IOE_BufferRX[2] = {0x00, 0x00};  
 2148              		.loc 1 625 0
 2149 000c 8DF80430 		strb	r3, [sp, #4]
 2150 0010 8DF80530 		strb	r3, [sp, #5]
 628:stm32f429i_discovery_ioe.c ****   IOE_DMA_Config(IOE_DMA_RX, (uint8_t*)IOE_BufferRX);
 2151              		.loc 1 628 0
 2152 0014 FFF7FEFF 		bl	IOE_DMA_Config
 2153              	.LVL209:
 631:stm32f429i_discovery_ioe.c ****   I2C_DMALastTransferCmd(IOE_I2C, ENABLE);
 2154              		.loc 1 631 0
 2155 0018 4FF4B840 		mov	r0, #23552
 2156 001c C4F20000 		movt	r0, 16384
 2157 0020 0121     		movs	r1, #1
 2158 0022 FFF7FEFF 		bl	I2C_DMALastTransferCmd
 2159              	.LVL210:
 634:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 2160              		.loc 1 634 0
 2161 0026 4FF4B840 		mov	r0, #23552
 2162 002a C4F20000 		movt	r0, 16384
 2163 002e 0121     		movs	r1, #1
 637:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 2164              		.loc 1 637 0
 2165 0030 6B4C     		ldr	r4, .L199
 634:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 2166              		.loc 1 634 0
 2167 0032 FFF7FEFF 		bl	I2C_GenerateSTART
 2168              	.LVL211:
 637:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 2169              		.loc 1 637 0
 2170 0036 4FF44050 		mov	r0, #12288
 2171 003a 2060     		str	r0, [r4, #0]
 638:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
 2172              		.loc 1 638 0
 2173 003c 05E0     		b	.L176
 2174              	.L178:
 640:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2175              		.loc 1 640 0
 2176 003e 2068     		ldr	r0, [r4, #0]
 2177 0040 411E     		subs	r1, r0, #1
 2178 0042 2160     		str	r1, [r4, #0]
 2179 0044 0028     		cmp	r0, #0
 2180 0046 00F0C780 		beq	.L198
 2181              	.L176:
 638:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
 2182              		.loc 1 638 0 discriminator 1
 2183 004a 4FF4B840 		mov	r0, #23552
 2184 004e 0121     		movs	r1, #1
 2185 0050 C4F20000 		movt	r0, 16384
 2186 0054 C1F20001 		movt	r1, 4096
 2187 0058 FFF7FEFF 		bl	I2C_GetFlagStatus
 2188              	.LVL212:
 2189 005c 0028     		cmp	r0, #0
 2190 005e EED0     		beq	.L178
 644:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Transmitter);
 2191              		.loc 1 644 0
 2192 0060 4FF4B840 		mov	r0, #23552
 2193 0064 8221     		movs	r1, #130
 2194 0066 C4F20000 		movt	r0, 16384
 2195 006a 0022     		movs	r2, #0
 2196 006c FFF7FEFF 		bl	I2C_Send7bitAddress
 2197              	.LVL213:
 647:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 2198              		.loc 1 647 0
 2199 0070 4FF44051 		mov	r1, #12288
 2200 0074 2160     		str	r1, [r4, #0]
 648:stm32f429i_discovery_ioe.c ****   while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) 
 2201              		.loc 1 648 0
 2202 0076 05E0     		b	.L179
 2203              	.L180:
 650:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2204              		.loc 1 650 0
 2205 0078 2368     		ldr	r3, [r4, #0]
 2206 007a 5A1E     		subs	r2, r3, #1
 2207 007c 2260     		str	r2, [r4, #0]
 2208 007e 002B     		cmp	r3, #0
 2209 0080 00F0AA80 		beq	.L198
 2210              	.L179:
 648:stm32f429i_discovery_ioe.c ****   while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) 
 2211              		.loc 1 648 0 discriminator 1
 2212 0084 4FF4B840 		mov	r0, #23552
 2213 0088 8221     		movs	r1, #130
 2214 008a C4F20000 		movt	r0, 16384
 2215 008e C0F20701 		movt	r1, 7
 2216 0092 FFF7FEFF 		bl	I2C_CheckEvent
 2217              	.LVL214:
 2218 0096 0028     		cmp	r0, #0
 2219 0098 EED0     		beq	.L180
 654:stm32f429i_discovery_ioe.c ****   I2C_SendData(IOE_I2C, RegisterAddr);  
 2220              		.loc 1 654 0
 2221 009a 4FF4B840 		mov	r0, #23552
 2222 009e C4F20000 		movt	r0, 16384
 2223 00a2 2946     		mov	r1, r5
 2224 00a4 FFF7FEFF 		bl	I2C_SendData
 2225              	.LVL215:
 657:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 2226              		.loc 1 657 0
 2227 00a8 4FF44052 		mov	r2, #12288
 2228 00ac 2260     		str	r2, [r4, #0]
 658:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF))) 
 2229              		.loc 1 658 0
 2230 00ae 0CE0     		b	.L181
 2231              	.L182:
 658:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF))) 
 2232              		.loc 1 658 0 is_stmt 0 discriminator 2
 2233 00b0 4FF4B840 		mov	r0, #23552
 2234 00b4 C4F20000 		movt	r0, 16384
 2235 00b8 FFF7FEFF 		bl	I2C_GetFlagStatus
 2236              	.LVL216:
 2237 00bc 98B9     		cbnz	r0, .L185
 660:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2238              		.loc 1 660 0 is_stmt 1
 2239 00be 2068     		ldr	r0, [r4, #0]
 2240 00c0 411E     		subs	r1, r0, #1
 2241 00c2 2160     		str	r1, [r4, #0]
 2242 00c4 0028     		cmp	r0, #0
 2243 00c6 00F08780 		beq	.L198
 2244              	.L181:
 658:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF))) 
 2245              		.loc 1 658 0 discriminator 1
 2246 00ca 4FF4B840 		mov	r0, #23552
 2247 00ce 8021     		movs	r1, #128
 2248 00d0 C1F20001 		movt	r1, 4096
 2249 00d4 C4F20000 		movt	r0, 16384
 2250 00d8 FFF7FEFF 		bl	I2C_GetFlagStatus
 2251              	.LVL217:
 2252 00dc 0421     		movs	r1, #4
 2253 00de C1F20001 		movt	r1, 4096
 2254 00e2 0028     		cmp	r0, #0
 2255 00e4 E4D0     		beq	.L182
 2256              	.L185:
 664:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 2257              		.loc 1 664 0
 2258 00e6 4FF4B840 		mov	r0, #23552
 2259 00ea C4F20000 		movt	r0, 16384
 2260 00ee 0121     		movs	r1, #1
 2261 00f0 FFF7FEFF 		bl	I2C_GenerateSTART
 2262              	.LVL218:
 667:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 2263              		.loc 1 667 0
 2264 00f4 4FF44053 		mov	r3, #12288
 2265 00f8 2360     		str	r3, [r4, #0]
 668:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
 2266              		.loc 1 668 0
 2267 00fa 04E0     		b	.L183
 2268              	.L186:
 670:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2269              		.loc 1 670 0
 2270 00fc 2368     		ldr	r3, [r4, #0]
 2271 00fe 5A1E     		subs	r2, r3, #1
 2272 0100 2260     		str	r2, [r4, #0]
 2273 0102 002B     		cmp	r3, #0
 2274 0104 68D0     		beq	.L198
 2275              	.L183:
 668:stm32f429i_discovery_ioe.c ****   while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
 2276              		.loc 1 668 0 discriminator 1
 2277 0106 4FF4B840 		mov	r0, #23552
 2278 010a 0121     		movs	r1, #1
 2279 010c C4F20000 		movt	r0, 16384
 2280 0110 C1F20001 		movt	r1, 4096
 2281 0114 FFF7FEFF 		bl	I2C_GetFlagStatus
 2282              	.LVL219:
 2283 0118 0028     		cmp	r0, #0
 2284 011a EFD0     		beq	.L186
 674:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Receiver);
 2285              		.loc 1 674 0
 2286 011c 4FF4B840 		mov	r0, #23552
 2287 0120 C4F20000 		movt	r0, 16384
 2288 0124 8221     		movs	r1, #130
 2289 0126 0122     		movs	r2, #1
 2290 0128 FFF7FEFF 		bl	I2C_Send7bitAddress
 2291              	.LVL220:
 677:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 2292              		.loc 1 677 0
 2293 012c 4FF44050 		mov	r0, #12288
 2294 0130 2060     		str	r0, [r4, #0]
 678:stm32f429i_discovery_ioe.c ****   while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))   
 2295              		.loc 1 678 0
 2296 0132 04E0     		b	.L187
 2297              	.L188:
 680:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2298              		.loc 1 680 0
 2299 0134 2068     		ldr	r0, [r4, #0]
 2300 0136 411E     		subs	r1, r0, #1
 2301 0138 2160     		str	r1, [r4, #0]
 2302 013a 0028     		cmp	r0, #0
 2303 013c 4CD0     		beq	.L198
 2304              	.L187:
 678:stm32f429i_discovery_ioe.c ****   while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))   
 2305              		.loc 1 678 0 discriminator 1
 2306 013e 4FF4B840 		mov	r0, #23552
 2307 0142 0221     		movs	r1, #2
 2308 0144 C4F20000 		movt	r0, 16384
 2309 0148 C0F20301 		movt	r1, 3
 2310 014c FFF7FEFF 		bl	I2C_CheckEvent
 2311              	.LVL221:
 2312 0150 0028     		cmp	r0, #0
 2313 0152 EFD0     		beq	.L188
 684:stm32f429i_discovery_ioe.c ****   I2C_DMACmd(IOE_I2C,ENABLE);
 2314              		.loc 1 684 0
 2315 0154 4FF4B840 		mov	r0, #23552
 2316 0158 C4F20000 		movt	r0, 16384
 2317 015c 0121     		movs	r1, #1
 2318 015e FFF7FEFF 		bl	I2C_DMACmd
 2319              	.LVL222:
 687:stm32f429i_discovery_ioe.c ****   DMA_Cmd(IOE_DMA_RX_STREAM, ENABLE);
 2320              		.loc 1 687 0
 2321 0162 46F21000 		movw	r0, #24592
 2322 0166 0121     		movs	r1, #1
 2323 0168 C4F20200 		movt	r0, 16386
 2324 016c FFF7FEFF 		bl	DMA_Cmd
 2325              	.LVL223:
 690:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = 2 * TIMEOUT_MAX;
 2326              		.loc 1 690 0
 2327 0170 4FF4C041 		mov	r1, #24576
 2328 0174 2160     		str	r1, [r4, #0]
 691:stm32f429i_discovery_ioe.c ****   while (!DMA_GetFlagStatus(IOE_DMA_RX_STREAM,IOE_DMA_RX_TCFLAG))
 2329              		.loc 1 691 0
 2330 0176 03E0     		b	.L189
 2331              	.L190:
 693:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2332              		.loc 1 693 0
 2333 0178 2368     		ldr	r3, [r4, #0]
 2334 017a 5A1E     		subs	r2, r3, #1
 2335 017c 2260     		str	r2, [r4, #0]
 2336 017e 5BB3     		cbz	r3, .L198
 2337              	.L189:
 691:stm32f429i_discovery_ioe.c ****   while (!DMA_GetFlagStatus(IOE_DMA_RX_STREAM,IOE_DMA_RX_TCFLAG))
 2338              		.loc 1 691 0 discriminator 1
 2339 0180 46F21000 		movw	r0, #24592
 2340 0184 2021     		movs	r1, #32
 2341 0186 C4F20200 		movt	r0, 16386
 2342 018a C1F20001 		movt	r1, 4096
 2343 018e FFF7FEFF 		bl	DMA_GetFlagStatus
 2344              	.LVL224:
 2345 0192 0028     		cmp	r0, #0
 2346 0194 F0D0     		beq	.L190
 697:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTOP(IOE_I2C, ENABLE);
 2347              		.loc 1 697 0
 2348 0196 4FF4B840 		mov	r0, #23552
 2349 019a C4F20000 		movt	r0, 16384
 2350 019e 0121     		movs	r1, #1
 2351 01a0 FFF7FEFF 		bl	I2C_GenerateSTOP
 2352              	.LVL225:
 700:stm32f429i_discovery_ioe.c ****   DMA_Cmd(IOE_DMA_RX_STREAM, DISABLE);
 2353              		.loc 1 700 0
 2354 01a4 46F21000 		movw	r0, #24592
 2355 01a8 C4F20200 		movt	r0, 16386
 2356 01ac 0021     		movs	r1, #0
 2357 01ae FFF7FEFF 		bl	DMA_Cmd
 2358              	.LVL226:
 703:stm32f429i_discovery_ioe.c ****   I2C_DMACmd(IOE_I2C,DISABLE);
 2359              		.loc 1 703 0
 2360 01b2 4FF4B840 		mov	r0, #23552
 2361 01b6 C4F20000 		movt	r0, 16384
 2362 01ba 0021     		movs	r1, #0
 2363 01bc FFF7FEFF 		bl	I2C_DMACmd
 2364              	.LVL227:
 706:stm32f429i_discovery_ioe.c ****  DMA_ClearFlag(IOE_DMA_RX_STREAM,IOE_DMA_RX_TCFLAG);
 2365              		.loc 1 706 0
 2366 01c0 46F21000 		movw	r0, #24592
 2367 01c4 2021     		movs	r1, #32
 2368 01c6 C4F20200 		movt	r0, 16386
 2369 01ca C1F20001 		movt	r1, 4096
 2370 01ce FFF7FEFF 		bl	DMA_ClearFlag
 2371              	.LVL228:
 709:stm32f429i_discovery_ioe.c ****   return (uint8_t)IOE_BufferRX[0];
 2372              		.loc 1 709 0
 2373 01d2 9DF80400 		ldrb	r0, [sp, #4]	@ zero_extendqisi2
 2374 01d6 01E0     		b	.L177
 2375              	.L198:
 693:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2376              		.loc 1 693 0 discriminator 1
 2377 01d8 FFF7FEFF 		bl	IOE_TimeoutUserCallback
 2378              	.LVL229:
 2379              	.L177:
 710:stm32f429i_discovery_ioe.c **** }
 2380              		.loc 1 710 0
 2381 01dc 03B0     		add	sp, sp, #12
 2382 01de 30BD     		pop	{r4, r5, pc}
 2383              	.L200:
 2384              		.align	2
 2385              	.L199:
 2386 01e0 00000000 		.word	.LANCHOR0
 2387              		.cfi_endproc
 2388              	.LFE126:
 2390 01e4 AFF30080 		.section	.text.I2C_DMA_WriteDeviceRegister,"ax",%progbits
 2390      AFF30080 
 2390      AFF30080 
 2391              		.align	2
 2392              		.p2align 4,,15
 2393              		.global	I2C_DMA_WriteDeviceRegister
 2394              		.thumb
 2395              		.thumb_func
 2397              	I2C_DMA_WriteDeviceRegister:
 2398              	.LFB125:
 524:stm32f429i_discovery_ioe.c **** {
 2399              		.loc 1 524 0
 2400              		.cfi_startproc
 2401              		@ args = 0, pretend = 0, frame = 8
 2402              		@ frame_needed = 0, uses_anonymous_args = 0
 2403              	.LVL230:
 2404 0000 30B5     		push	{r4, r5, lr}
 2405              	.LCFI27:
 2406              		.cfi_def_cfa_offset 12
 2407              		.cfi_offset 4, -12
 2408              		.cfi_offset 5, -8
 2409              		.cfi_offset 14, -4
 2410 0002 83B0     		sub	sp, sp, #12
 2411              	.LCFI28:
 2412              		.cfi_def_cfa_offset 24
 529:stm32f429i_discovery_ioe.c ****   IOE_BufferTX = RegisterValue;
 2413              		.loc 1 529 0
 2414 0004 02AB     		add	r3, sp, #8
 524:stm32f429i_discovery_ioe.c **** {
 2415              		.loc 1 524 0
 2416 0006 0546     		mov	r5, r0
 529:stm32f429i_discovery_ioe.c ****   IOE_BufferTX = RegisterValue;
 2417              		.loc 1 529 0
 2418 0008 03F8011D 		strb	r1, [r3, #-1]!
 2419              	.LVL231:
 532:stm32f429i_discovery_ioe.c ****   IOE_DMA_Config(IOE_DMA_TX, (uint8_t*)(&IOE_BufferTX));
 2420              		.loc 1 532 0
 2421 000c 0020     		movs	r0, #0
 2422              	.LVL232:
 2423 000e 1946     		mov	r1, r3
 2424              	.LVL233:
 2425 0010 FFF7FEFF 		bl	IOE_DMA_Config
 2426              	.LVL234:
 535:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 2427              		.loc 1 535 0
 2428 0014 4FF4B840 		mov	r0, #23552
 2429 0018 C4F20000 		movt	r0, 16384
 2430 001c 0121     		movs	r1, #1
 538:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 2431              		.loc 1 538 0
 2432 001e 5A4C     		ldr	r4, .L222
 535:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTART(IOE_I2C, ENABLE);
 2433              		.loc 1 535 0
 2434 0020 FFF7FEFF 		bl	I2C_GenerateSTART
 2435              	.LVL235:
 538:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 2436              		.loc 1 538 0
 2437 0024 4FF44050 		mov	r0, #12288
 2438 0028 2060     		str	r0, [r4, #0]
 539:stm32f429i_discovery_ioe.c ****   while (I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB) == RESET) 
 2439              		.loc 1 539 0
 2440 002a 05E0     		b	.L202
 2441              	.L204:
 541:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2442              		.loc 1 541 0
 2443 002c 2168     		ldr	r1, [r4, #0]
 2444 002e 4A1E     		subs	r2, r1, #1
 2445 0030 2260     		str	r2, [r4, #0]
 2446 0032 0029     		cmp	r1, #0
 2447 0034 00F0A480 		beq	.L221
 2448              	.L202:
 539:stm32f429i_discovery_ioe.c ****   while (I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB) == RESET) 
 2449              		.loc 1 539 0 discriminator 1
 2450 0038 4FF4B840 		mov	r0, #23552
 2451 003c 0121     		movs	r1, #1
 2452 003e C4F20000 		movt	r0, 16384
 2453 0042 C1F20001 		movt	r1, 4096
 2454 0046 FFF7FEFF 		bl	I2C_GetFlagStatus
 2455              	.LVL236:
 2456 004a 0028     		cmp	r0, #0
 2457 004c EED0     		beq	.L204
 545:stm32f429i_discovery_ioe.c ****   I2C_Send7bitAddress(IOE_I2C, IOE_ADDR, I2C_Direction_Transmitter);
 2458              		.loc 1 545 0
 2459 004e 4FF4B840 		mov	r0, #23552
 2460 0052 8221     		movs	r1, #130
 2461 0054 C4F20000 		movt	r0, 16384
 2462 0058 0022     		movs	r2, #0
 2463 005a FFF7FEFF 		bl	I2C_Send7bitAddress
 2464              	.LVL237:
 548:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 2465              		.loc 1 548 0
 2466 005e 4FF44051 		mov	r1, #12288
 2467 0062 2160     		str	r1, [r4, #0]
 549:stm32f429i_discovery_ioe.c ****   while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 2468              		.loc 1 549 0
 2469 0064 05E0     		b	.L205
 2470              	.L206:
 551:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2471              		.loc 1 551 0
 2472 0066 2368     		ldr	r3, [r4, #0]
 2473 0068 581E     		subs	r0, r3, #1
 2474 006a 2060     		str	r0, [r4, #0]
 2475 006c 002B     		cmp	r3, #0
 2476 006e 00F08780 		beq	.L221
 2477              	.L205:
 549:stm32f429i_discovery_ioe.c ****   while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 2478              		.loc 1 549 0 discriminator 1
 2479 0072 4FF4B840 		mov	r0, #23552
 2480 0076 8221     		movs	r1, #130
 2481 0078 C4F20000 		movt	r0, 16384
 2482 007c C0F20701 		movt	r1, 7
 2483 0080 FFF7FEFF 		bl	I2C_CheckEvent
 2484              	.LVL238:
 2485 0084 0028     		cmp	r0, #0
 2486 0086 EED0     		beq	.L206
 555:stm32f429i_discovery_ioe.c ****   I2C_SendData(IOE_I2C, RegisterAddr);
 2487              		.loc 1 555 0
 2488 0088 4FF4B840 		mov	r0, #23552
 2489 008c C4F20000 		movt	r0, 16384
 2490 0090 2946     		mov	r1, r5
 2491 0092 FFF7FEFF 		bl	I2C_SendData
 2492              	.LVL239:
 558:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 2493              		.loc 1 558 0
 2494 0096 4FF44052 		mov	r2, #12288
 2495 009a 2260     		str	r2, [r4, #0]
 559:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF))) 
 2496              		.loc 1 559 0
 2497 009c 0BE0     		b	.L207
 2498              	.L208:
 559:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF))) 
 2499              		.loc 1 559 0 is_stmt 0 discriminator 2
 2500 009e 4FF4B840 		mov	r0, #23552
 2501 00a2 C4F20000 		movt	r0, 16384
 2502 00a6 FFF7FEFF 		bl	I2C_GetFlagStatus
 2503              	.LVL240:
 2504 00aa 90B9     		cbnz	r0, .L211
 561:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2505              		.loc 1 561 0 is_stmt 1
 2506 00ac 2168     		ldr	r1, [r4, #0]
 2507 00ae 4A1E     		subs	r2, r1, #1
 2508 00b0 2260     		str	r2, [r4, #0]
 2509 00b2 0029     		cmp	r1, #0
 2510 00b4 64D0     		beq	.L221
 2511              	.L207:
 559:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF))) 
 2512              		.loc 1 559 0 discriminator 1
 2513 00b6 4FF4B840 		mov	r0, #23552
 2514 00ba 8021     		movs	r1, #128
 2515 00bc C1F20001 		movt	r1, 4096
 2516 00c0 C4F20000 		movt	r0, 16384
 2517 00c4 FFF7FEFF 		bl	I2C_GetFlagStatus
 2518              	.LVL241:
 2519 00c8 0421     		movs	r1, #4
 2520 00ca C1F20001 		movt	r1, 4096
 2521 00ce 0028     		cmp	r0, #0
 2522 00d0 E5D0     		beq	.L208
 2523              	.L211:
 565:stm32f429i_discovery_ioe.c ****   I2C_DMACmd(IOE_I2C,ENABLE);
 2524              		.loc 1 565 0
 2525 00d2 4FF4B840 		mov	r0, #23552
 2526 00d6 C4F20000 		movt	r0, 16384
 2527 00da 0121     		movs	r1, #1
 2528 00dc FFF7FEFF 		bl	I2C_DMACmd
 2529              	.LVL242:
 568:stm32f429i_discovery_ioe.c ****   DMA_Cmd(IOE_DMA_TX_STREAM, ENABLE);
 2530              		.loc 1 568 0
 2531 00e0 46F2A000 		movw	r0, #24736
 2532 00e4 C4F20200 		movt	r0, 16386
 2533 00e8 0121     		movs	r1, #1
 2534 00ea FFF7FEFF 		bl	DMA_Cmd
 2535              	.LVL243:
 571:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = TIMEOUT_MAX;
 2536              		.loc 1 571 0
 2537 00ee 4FF44053 		mov	r3, #12288
 2538 00f2 2360     		str	r3, [r4, #0]
 572:stm32f429i_discovery_ioe.c ****   while (!DMA_GetFlagStatus(IOE_DMA_TX_STREAM,IOE_DMA_TX_TCFLAG))
 2539              		.loc 1 572 0
 2540 00f4 04E0     		b	.L209
 2541              	.L212:
 574:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2542              		.loc 1 574 0
 2543 00f6 2368     		ldr	r3, [r4, #0]
 2544 00f8 581E     		subs	r0, r3, #1
 2545 00fa 2060     		str	r0, [r4, #0]
 2546 00fc 002B     		cmp	r3, #0
 2547 00fe 3FD0     		beq	.L221
 2548              	.L209:
 572:stm32f429i_discovery_ioe.c ****   while (!DMA_GetFlagStatus(IOE_DMA_TX_STREAM,IOE_DMA_TX_TCFLAG))
 2549              		.loc 1 572 0 discriminator 1
 2550 0100 46F2A000 		movw	r0, #24736
 2551 0104 0021     		movs	r1, #0
 2552 0106 C4F20200 		movt	r0, 16386
 2553 010a C2F22001 		movt	r1, 8224
 2554 010e FFF7FEFF 		bl	DMA_GetFlagStatus
 2555              	.LVL244:
 2556 0112 0028     		cmp	r0, #0
 2557 0114 EFD0     		beq	.L212
 578:stm32f429i_discovery_ioe.c ****   IOE_TimeOut = 0xFF * TIMEOUT_MAX;
 2558              		.loc 1 578 0
 2559 0116 4FF45040 		mov	r0, #53248
 2560 011a C0F22F00 		movt	r0, 47
 2561 011e 2060     		str	r0, [r4, #0]
 579:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF)))  
 2562              		.loc 1 579 0
 2563 0120 03E0     		b	.L213
 2564              	.L214:
 581:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2565              		.loc 1 581 0
 2566 0122 2168     		ldr	r1, [r4, #0]
 2567 0124 4A1E     		subs	r2, r1, #1
 2568 0126 2260     		str	r2, [r4, #0]
 2569 0128 51B3     		cbz	r1, .L221
 2570              	.L213:
 579:stm32f429i_discovery_ioe.c ****   while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF)))  
 2571              		.loc 1 579 0 discriminator 1
 2572 012a 4FF4B840 		mov	r0, #23552
 2573 012e 0421     		movs	r1, #4
 2574 0130 C4F20000 		movt	r0, 16384
 2575 0134 C1F20001 		movt	r1, 4096
 2576 0138 FFF7FEFF 		bl	I2C_GetFlagStatus
 2577              	.LVL245:
 2578 013c 0028     		cmp	r0, #0
 2579 013e F0D0     		beq	.L214
 585:stm32f429i_discovery_ioe.c ****   I2C_GenerateSTOP(IOE_I2C, ENABLE);
 2580              		.loc 1 585 0
 2581 0140 4FF4B840 		mov	r0, #23552
 2582 0144 C4F20000 		movt	r0, 16384
 2583 0148 0121     		movs	r1, #1
 2584 014a FFF7FEFF 		bl	I2C_GenerateSTOP
 2585              	.LVL246:
 588:stm32f429i_discovery_ioe.c ****   DMA_Cmd(IOE_DMA_TX_STREAM, DISABLE);
 2586              		.loc 1 588 0
 2587 014e 46F2A000 		movw	r0, #24736
 2588 0152 C4F20200 		movt	r0, 16386
 2589 0156 0021     		movs	r1, #0
 2590 0158 FFF7FEFF 		bl	DMA_Cmd
 2591              	.LVL247:
 591:stm32f429i_discovery_ioe.c ****   I2C_DMACmd(IOE_I2C,DISABLE);
 2592              		.loc 1 591 0
 2593 015c 4FF4B840 		mov	r0, #23552
 2594 0160 C4F20000 		movt	r0, 16384
 2595 0164 0021     		movs	r1, #0
 2596 0166 FFF7FEFF 		bl	I2C_DMACmd
 2597              	.LVL248:
 594:stm32f429i_discovery_ioe.c ****   DMA_ClearFlag(IOE_DMA_TX_STREAM,IOE_DMA_TX_TCFLAG);
 2598              		.loc 1 594 0
 2599 016a 46F2A000 		movw	r0, #24736
 2600 016e 0021     		movs	r1, #0
 2601 0170 C4F20200 		movt	r0, 16386
 2602 0174 C2F22001 		movt	r1, 8224
 2603 0178 FFF7FEFF 		bl	DMA_ClearFlag
 2604              	.LVL249:
 615:stm32f429i_discovery_ioe.c ****   return read_verif;
 2605              		.loc 1 615 0
 2606 017c 0020     		movs	r0, #0
 2607 017e 01E0     		b	.L203
 2608              	.L221:
 581:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
 2609              		.loc 1 581 0 discriminator 1
 2610 0180 FFF7FEFF 		bl	IOE_TimeoutUserCallback
 2611              	.LVL250:
 2612              	.L203:
 616:stm32f429i_discovery_ioe.c **** }
 2613              		.loc 1 616 0
 2614 0184 03B0     		add	sp, sp, #12
 2615 0186 30BD     		pop	{r4, r5, pc}
 2616              	.L223:
 2617              		.align	2
 2618              	.L222:
 2619 0188 00000000 		.word	.LANCHOR0
 2620              		.cfi_endproc
 2621              	.LFE125:
 2623 018c AFF30080 		.section	.text.IOE_IsOperational,"ax",%progbits
 2624              		.align	2
 2625              		.p2align 4,,15
 2626              		.global	IOE_IsOperational
 2627              		.thumb
 2628              		.thumb_func
 2630              	IOE_IsOperational:
 2631              	.LFB117:
 271:stm32f429i_discovery_ioe.c **** {
 2632              		.loc 1 271 0
 2633              		.cfi_startproc
 2634              		@ args = 0, pretend = 0, frame = 0
 2635              		@ frame_needed = 0, uses_anonymous_args = 0
 2636 0000 08B5     		push	{r3, lr}
 2637              	.LCFI29:
 2638              		.cfi_def_cfa_offset 8
 2639              		.cfi_offset 3, -8
 2640              		.cfi_offset 14, -4
 273:stm32f429i_discovery_ioe.c ****   if( IOE_ReadID() != (uint16_t)STMPE811_ID )
 2641              		.loc 1 273 0
 2642 0002 FFF7FEFF 		bl	IOE_ReadID
 2643              	.LVL251:
 2644 0006 40F61103 		movw	r3, #2065
 2645 000a 9842     		cmp	r0, r3
 2646 000c 08D0     		beq	.L226
 276:stm32f429i_discovery_ioe.c ****     if (IOE_TimeOut == 0)
 2647              		.loc 1 276 0
 2648 000e 0548     		ldr	r0, .L229
 2649 0010 0168     		ldr	r1, [r0, #0]
 2650 0012 09B1     		cbz	r1, .L228
 282:stm32f429i_discovery_ioe.c ****       return IOE_FAILURE; /* ID is not Correct */
 2651              		.loc 1 282 0
 2652 0014 0120     		movs	r0, #1
 289:stm32f429i_discovery_ioe.c **** }
 2653              		.loc 1 289 0
 2654 0016 08BD     		pop	{r3, pc}
 2655              	.L228:
 2656 0018 BDE80840 		pop	{r3, lr}
 278:stm32f429i_discovery_ioe.c ****       return(IOE_TimeoutUserCallback());
 2657              		.loc 1 278 0
 2658 001c FFF7FEBF 		b	IOE_TimeoutUserCallback
 2659              	.LVL252:
 2660              	.L226:
 287:stm32f429i_discovery_ioe.c ****     return IOE_OK; /* ID is correct */
 2661              		.loc 1 287 0
 2662 0020 0020     		movs	r0, #0
 2663 0022 08BD     		pop	{r3, pc}
 2664              	.L230:
 2665              		.align	2
 2666              	.L229:
 2667 0024 00000000 		.word	.LANCHOR0
 2668              		.cfi_endproc
 2669              	.LFE117:
 2671 0028 AFF30080 		.section	.text.IOE_Config,"ax",%progbits
 2671      AFF30080 
 2672              		.align	2
 2673              		.p2align 4,,15
 2674              		.global	IOE_Config
 2675              		.thumb
 2676              		.thumb_func
 2678              	IOE_Config:
 2679              	.LFB112:
 128:stm32f429i_discovery_ioe.c **** {
 2680              		.loc 1 128 0
 2681              		.cfi_startproc
 2682              		@ args = 0, pretend = 0, frame = 16
 2683              		@ frame_needed = 0, uses_anonymous_args = 0
 2684 0000 10B5     		push	{r4, lr}
 2685              	.LCFI30:
 2686              		.cfi_def_cfa_offset 8
 2687              		.cfi_offset 4, -8
 2688              		.cfi_offset 14, -4
 2689 0002 84B0     		sub	sp, sp, #16
 2690              	.LCFI31:
 2691              		.cfi_def_cfa_offset 24
 130:stm32f429i_discovery_ioe.c ****   IOE_GPIO_Config(); 
 2692              		.loc 1 130 0
 2693 0004 FFF7FEFF 		bl	IOE_GPIO_Config
 2694              	.LVL253:
 2695              	.LBB48:
 2696              	.LBB49:
 952:stm32f429i_discovery_ioe.c ****   if ((IOE_I2C->CR1 & I2C_CR1_PE) == 0)
 2697              		.loc 1 952 0
 2698 0008 4FF4B843 		mov	r3, #23552
 2699 000c C4F20003 		movt	r3, 16384
 2700 0010 1888     		ldrh	r0, [r3, #0]
 2701 0012 10F00103 		ands	r3, r0, #1
 2702 0016 22D1     		bne	.L232
 959:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 2703              		.loc 1 959 0
 2704 0018 4FF48044 		mov	r4, #16384
 960:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
 2705              		.loc 1 960 0
 2706 001c 04A9     		add	r1, sp, #16
 2707 001e 48F2A062 		movw	r2, #34464
 2708 0022 C0F20102 		movt	r2, 1
 963:stm32f429i_discovery_ioe.c ****     I2C_Init(IOE_I2C, &I2C_InitStructure);
 2709              		.loc 1 963 0
 2710 0026 2004     		lsls	r0, r4, #16
 960:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
 2711              		.loc 1 960 0
 2712 0028 41F8102D 		str	r2, [r1, #-16]!
 963:stm32f429i_discovery_ioe.c ****     I2C_Init(IOE_I2C, &I2C_InitStructure);
 2713              		.loc 1 963 0
 2714 002c 40F4B840 		orr	r0, r0, #23552
 2715 0030 6946     		mov	r1, sp
 955:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 2716              		.loc 1 955 0
 2717 0032 ADF80430 		strh	r3, [sp, #4]	@ movhi
 956:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 2718              		.loc 1 956 0
 2719 0036 4BF6FF72 		movw	r2, #49151
 957:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 2720              		.loc 1 957 0
 2721 003a ADF80830 		strh	r3, [sp, #8]	@ movhi
 958:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 2722              		.loc 1 958 0
 2723 003e 4FF48063 		mov	r3, #1024
 956:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 2724              		.loc 1 956 0
 2725 0042 ADF80620 		strh	r2, [sp, #6]	@ movhi
 958:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 2726              		.loc 1 958 0
 2727 0046 ADF80A30 		strh	r3, [sp, #10]	@ movhi
 959:stm32f429i_discovery_ioe.c ****     I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 2728              		.loc 1 959 0
 2729 004a ADF80C40 		strh	r4, [sp, #12]	@ movhi
 963:stm32f429i_discovery_ioe.c ****     I2C_Init(IOE_I2C, &I2C_InitStructure);
 2730              		.loc 1 963 0
 2731 004e FFF7FEFF 		bl	I2C_Init
 2732              	.LVL254:
 966:stm32f429i_discovery_ioe.c ****     I2C_Cmd(IOE_I2C, ENABLE);
 2733              		.loc 1 966 0
 2734 0052 2104     		lsls	r1, r4, #16
 2735 0054 41F4B840 		orr	r0, r1, #23552
 2736 0058 0121     		movs	r1, #1
 2737 005a FFF7FEFF 		bl	I2C_Cmd
 2738              	.LVL255:
 2739              	.L232:
 2740              	.LBE49:
 2741              	.LBE48:
 136:stm32f429i_discovery_ioe.c ****   if(IOE_IsOperational())
 2742              		.loc 1 136 0
 2743 005e FFF7FEFF 		bl	IOE_IsOperational
 2744              	.LVL256:
 2745 0062 0446     		mov	r4, r0
 2746 0064 10B1     		cbz	r0, .L235
 138:stm32f429i_discovery_ioe.c ****     return IOE_NOT_OPERATIONAL;
 2747              		.loc 1 138 0
 2748 0066 0420     		movs	r0, #4
 2749              	.L233:
 151:stm32f429i_discovery_ioe.c **** }
 2750              		.loc 1 151 0
 2751 0068 04B0     		add	sp, sp, #16
 2752 006a 10BD     		pop	{r4, pc}
 2753              	.L235:
 142:stm32f429i_discovery_ioe.c ****   IOE_Reset(); 
 2754              		.loc 1 142 0
 2755 006c FFF7FEFF 		bl	IOE_Reset
 2756              	.LVL257:
 146:stm32f429i_discovery_ioe.c ****   IOE_FnctCmd(IOE_ADC_FCT, ENABLE);
 2757              		.loc 1 146 0
 2758 0070 0120     		movs	r0, #1
 2759 0072 0146     		mov	r1, r0
 2760 0074 FFF7FEFF 		bl	IOE_FnctCmd
 2761              	.LVL258:
 147:stm32f429i_discovery_ioe.c ****   IOE_TP_Config();
 2762              		.loc 1 147 0
 2763 0078 FFF7FEFF 		bl	IOE_TP_Config
 2764              	.LVL259:
 150:stm32f429i_discovery_ioe.c ****   return IOE_OK; 
 2765              		.loc 1 150 0
 2766 007c 2046     		mov	r0, r4
 2767 007e F3E7     		b	.L233
 2768              		.cfi_endproc
 2769              	.LFE112:
 2771              		.global	IOE_TimeOut
 2772              		.global	TP_State
 2773              		.section	.data.IOE_TimeOut,"aw",%progbits
 2774              		.align	2
 2775              		.set	.LANCHOR0,. + 0
 2778              	IOE_TimeOut:
 2779 0000 00300000 		.word	12288
 2780              		.section	.bss.TP_State,"aw",%nobits
 2781              		.align	2
 2782              		.set	.LANCHOR1,. + 0
 2785              	TP_State:
 2786 0000 00000000 		.space	8
 2786      00000000 
 2787              		.section	.bss._y.7705,"aw",%nobits
 2788              		.align	2
 2789              		.set	.LANCHOR3,. + 0
 2792              	_y.7705:
 2793 0000 00000000 		.space	4
 2794              		.section	.bss._x.7704,"aw",%nobits
 2795              		.align	2
 2796              		.set	.LANCHOR2,. + 0
 2799              	_x.7704:
 2800 0000 00000000 		.space	4
 2801              		.text
 2802              	.Letext0:
 2803              		.file 2 "/home/pedro/gcc-arm-none-eabi-4_7-2013q3/bin/../lib/gcc/arm-none-eabi/4.7.4/include/stdin
 2804              		.file 3 "core/stm32f4xx.h"
 2805              		.file 4 "STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dma.h"
 2806              		.file 5 "STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_gpio.h"
 2807              		.file 6 "STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_i2c.h"
 2808              		.file 7 "stm32f429i_discovery_ioe.h"
 2809              		.file 8 "core/core_cm4.h"
 2810              		.file 9 "STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rcc.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f429i_discovery_ioe.c
     /tmp/ccjNteAN.s:21     .text.IOE_GPIO_Config:00000000 $t
     /tmp/ccjNteAN.s:26     .text.IOE_GPIO_Config:00000000 IOE_GPIO_Config
     /tmp/ccjNteAN.s:130    .text.IOE_DMA_Config:00000000 $t
     /tmp/ccjNteAN.s:135    .text.IOE_DMA_Config:00000000 IOE_DMA_Config
     /tmp/ccjNteAN.s:255    .text.IOE_TimeoutUserCallback:00000000 $t
     /tmp/ccjNteAN.s:261    .text.IOE_TimeoutUserCallback:00000000 IOE_TimeoutUserCallback
     /tmp/ccjNteAN.s:350    .text.I2C_ReadDataBuffer:00000000 $t
     /tmp/ccjNteAN.s:356    .text.I2C_ReadDataBuffer:00000000 I2C_ReadDataBuffer
     /tmp/ccjNteAN.s:609    .text.I2C_ReadDataBuffer:000001b4 $d
     /tmp/ccjNteAN.s:616    .text.I2C_ReadDeviceRegister:00000000 $t
     /tmp/ccjNteAN.s:622    .text.I2C_ReadDeviceRegister:00000000 I2C_ReadDeviceRegister
     /tmp/ccjNteAN.s:876    .text.I2C_ReadDeviceRegister:000001c4 $d
     /tmp/ccjNteAN.s:881    .text.IOE_ReadID:00000000 $t
     /tmp/ccjNteAN.s:887    .text.IOE_ReadID:00000000 IOE_ReadID
     /tmp/ccjNteAN.s:923    .text.IOE_GetGITStatus:00000000 $t
     /tmp/ccjNteAN.s:929    .text.IOE_GetGITStatus:00000000 IOE_GetGITStatus
     /tmp/ccjNteAN.s:973    .text.I2C_WriteDeviceRegister:00000000 $t
     /tmp/ccjNteAN.s:979    .text.I2C_WriteDeviceRegister:00000000 I2C_WriteDeviceRegister
     /tmp/ccjNteAN.s:1172   .text.I2C_WriteDeviceRegister:00000140 $d
     /tmp/ccjNteAN.s:1179   .text.IOE_IOAFConfig:00000000 $t
     /tmp/ccjNteAN.s:1185   .text.IOE_IOAFConfig:00000000 IOE_IOAFConfig
     /tmp/ccjNteAN.s:1232   .text.IOE_GITConfig:00000000 $t
     /tmp/ccjNteAN.s:1238   .text.IOE_GITConfig:00000000 IOE_GITConfig
     /tmp/ccjNteAN.s:1285   .text.IOE_GITCmd:00000000 $t
     /tmp/ccjNteAN.s:1291   .text.IOE_GITCmd:00000000 IOE_GITCmd
     /tmp/ccjNteAN.s:1334   .text.IOE_TPITConfig:00000000 $t
     /tmp/ccjNteAN.s:1340   .text.IOE_TPITConfig:00000000 IOE_TPITConfig
     /tmp/ccjNteAN.s:1371   .text.IOE_FnctCmd:00000000 $t
     /tmp/ccjNteAN.s:1377   .text.IOE_FnctCmd:00000000 IOE_FnctCmd
     /tmp/ccjNteAN.s:1424   .text.IOE_TP_Config:00000000 $t
     /tmp/ccjNteAN.s:1430   .text.IOE_TP_Config:00000000 IOE_TP_Config
     /tmp/ccjNteAN.s:1545   .text.IOE_TP_Config:00000094 $d
     /tmp/ccjNteAN.s:1550   .text.IOE_Reset:00000000 $t
     /tmp/ccjNteAN.s:1556   .text.IOE_Reset:00000000 IOE_Reset
     /tmp/ccjNteAN.s:1616   .text.IOE_ClearGITPending:00000000 $t
     /tmp/ccjNteAN.s:1622   .text.IOE_ClearGITPending:00000000 IOE_ClearGITPending
     /tmp/ccjNteAN.s:1647   .text.IOE_TP_GetState:00000000 $t
     /tmp/ccjNteAN.s:1653   .text.IOE_TP_GetState:00000000 IOE_TP_GetState
     /tmp/ccjNteAN.s:1844   .text.IOE_TP_GetState:000000dc $d
     /tmp/ccjNteAN.s:1853   .text.I2C_DMA_ReadDataBuffer:00000000 $t
     /tmp/ccjNteAN.s:1859   .text.I2C_DMA_ReadDataBuffer:00000000 I2C_DMA_ReadDataBuffer
     /tmp/ccjNteAN.s:2112   .text.I2C_DMA_ReadDataBuffer:000001d8 $d
     /tmp/ccjNteAN.s:2117   .text.I2C_DMA_ReadDeviceRegister:00000000 $t
     /tmp/ccjNteAN.s:2123   .text.I2C_DMA_ReadDeviceRegister:00000000 I2C_DMA_ReadDeviceRegister
     /tmp/ccjNteAN.s:2386   .text.I2C_DMA_ReadDeviceRegister:000001e0 $d
     /tmp/ccjNteAN.s:2391   .text.I2C_DMA_WriteDeviceRegister:00000000 $t
     /tmp/ccjNteAN.s:2397   .text.I2C_DMA_WriteDeviceRegister:00000000 I2C_DMA_WriteDeviceRegister
     /tmp/ccjNteAN.s:2619   .text.I2C_DMA_WriteDeviceRegister:00000188 $d
     /tmp/ccjNteAN.s:2624   .text.IOE_IsOperational:00000000 $t
     /tmp/ccjNteAN.s:2630   .text.IOE_IsOperational:00000000 IOE_IsOperational
     /tmp/ccjNteAN.s:2667   .text.IOE_IsOperational:00000024 $d
     /tmp/ccjNteAN.s:2672   .text.IOE_Config:00000000 $t
     /tmp/ccjNteAN.s:2678   .text.IOE_Config:00000000 IOE_Config
     /tmp/ccjNteAN.s:2778   .data.IOE_TimeOut:00000000 IOE_TimeOut
     /tmp/ccjNteAN.s:2785   .bss.TP_State:00000000 TP_State
     /tmp/ccjNteAN.s:2774   .data.IOE_TimeOut:00000000 $d
     /tmp/ccjNteAN.s:2781   .bss.TP_State:00000000 $d
     /tmp/ccjNteAN.s:2788   .bss._y.7705:00000000 $d
     /tmp/ccjNteAN.s:2792   .bss._y.7705:00000000 _y.7705
     /tmp/ccjNteAN.s:2795   .bss._x.7704:00000000 $d
     /tmp/ccjNteAN.s:2799   .bss._x.7704:00000000 _x.7704
                     .debug_frame:00000010 $d
     /tmp/ccjNteAN.s:615    .text.I2C_ReadDataBuffer:000001b8 $t
     /tmp/ccjNteAN.s:8948   .text.I2C_ReadDeviceRegister:000001c8 $t
     /tmp/ccjNteAN.s:1178   .text.I2C_WriteDeviceRegister:00000144 $t
     /tmp/ccjNteAN.s:1549   .text.IOE_TP_Config:00000098 $t
     /tmp/ccjNteAN.s:8948   .text.IOE_TP_GetState:000000e8 $t
     /tmp/ccjNteAN.s:2116   .text.I2C_DMA_ReadDataBuffer:000001dc $t
     /tmp/ccjNteAN.s:2390   .text.I2C_DMA_ReadDeviceRegister:000001e4 $t
     /tmp/ccjNteAN.s:2623   .text.I2C_DMA_WriteDeviceRegister:0000018c $t
     /tmp/ccjNteAN.s:2671   .text.IOE_IsOperational:00000028 $t

UNDEFINED SYMBOLS
RCC_APB1PeriphClockCmd
RCC_AHB1PeriphClockCmd
RCC_APB2PeriphClockCmd
RCC_APB1PeriphResetCmd
GPIO_PinAFConfig
GPIO_Init
DMA_DeInit
DMA_Init
I2C_GenerateSTOP
I2C_SoftwareResetCmd
I2C_DeInit
I2C_Cmd
I2C_Init
I2C_GenerateSTART
I2C_GetFlagStatus
I2C_Send7bitAddress
I2C_SendData
I2C_AcknowledgeConfig
I2C_NACKPositionConfig
I2C_ReceiveData
I2C_DMALastTransferCmd
I2C_CheckEvent
I2C_DMACmd
DMA_Cmd
DMA_GetFlagStatus
DMA_ClearFlag
